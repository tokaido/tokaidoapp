<!DOCTYPE HTML>
<html>
	<head>
		<meta http-equiv="Content-Type" content="html/html; charset=utf-8" />
		<title>GCDAsyncUdpSocket Class Reference</title>
		<meta id="xcode-display" name="xcode-display" content="render"/>
		<link rel="stylesheet" type="text/css" href="../css/styles.css" media="all" />
		<link rel="stylesheet" type="text/css" media="print" href="../css/stylesPrint.css" />
		<meta name="generator" content="appledoc 2.1 (build 858)" />
	</head>
	<body>
		<header id="top_header">
			<div id="library" class="hideInXcode">
				<h1><a id="libraryTitle" href="../index.html">CocoaAsyncSocket 0.0.1 </a></h1>
				<a id="developerHome" href="../index.html">Dustin Voss and Robbie Hanson</a>
			</div>
			
			<div id="title" role="banner">
				<h1 class="hideInXcode">GCDAsyncUdpSocket Class Reference</h1>
			</div>
			<ul id="headerButtons" role="toolbar">
				<li id="toc_button">
					<button aria-label="Show Table of Contents" role="checkbox" class="open" id="table_of_contents"><span class="disclosure"></span>Table of Contents</button>
				</li>
				<li id="jumpto_button" role="navigation">
					<select id="jumpTo">
	<option value="top">Jump To&#133;</option>
	
	<option value="overview">Overview</option>
	
	
	
	
	<option value="tasks">Tasks</option>
	
	
	
	
	
	
	
	<option value="class_methods">Class Methods</option>
	
	<option value="//api/name/familyFromAddress:">&nbsp;&nbsp;&nbsp;&nbsp;+ familyFromAddress:</option>
	
	<option value="//api/name/getHost:port:family:fromAddress:">&nbsp;&nbsp;&nbsp;&nbsp;+ getHost:port:family:fromAddress:</option>
	
	<option value="//api/name/getHost:port:fromAddress:">&nbsp;&nbsp;&nbsp;&nbsp;+ getHost:port:fromAddress:</option>
	
	<option value="//api/name/hostFromAddress:">&nbsp;&nbsp;&nbsp;&nbsp;+ hostFromAddress:</option>
	
	<option value="//api/name/isIPv4Address:">&nbsp;&nbsp;&nbsp;&nbsp;+ isIPv4Address:</option>
	
	<option value="//api/name/isIPv6Address:">&nbsp;&nbsp;&nbsp;&nbsp;+ isIPv6Address:</option>
	
	<option value="//api/name/portFromAddress:">&nbsp;&nbsp;&nbsp;&nbsp;+ portFromAddress:</option>
	
	
	
	
	<option value="instance_methods">Instance Methods</option>
	
	<option value="//api/name/beginReceiving:">&nbsp;&nbsp;&nbsp;&nbsp;- beginReceiving:</option>
	
	<option value="//api/name/bindToAddress:error:">&nbsp;&nbsp;&nbsp;&nbsp;- bindToAddress:error:</option>
	
	<option value="//api/name/bindToPort:error:">&nbsp;&nbsp;&nbsp;&nbsp;- bindToPort:error:</option>
	
	<option value="//api/name/bindToPort:interface:error:">&nbsp;&nbsp;&nbsp;&nbsp;- bindToPort:interface:error:</option>
	
	<option value="//api/name/close">&nbsp;&nbsp;&nbsp;&nbsp;- close</option>
	
	<option value="//api/name/closeAfterSending">&nbsp;&nbsp;&nbsp;&nbsp;- closeAfterSending</option>
	
	<option value="//api/name/connectToAddress:error:">&nbsp;&nbsp;&nbsp;&nbsp;- connectToAddress:error:</option>
	
	<option value="//api/name/connectToHost:onPort:error:">&nbsp;&nbsp;&nbsp;&nbsp;- connectToHost:onPort:error:</option>
	
	<option value="//api/name/connectedAddress">&nbsp;&nbsp;&nbsp;&nbsp;- connectedAddress</option>
	
	<option value="//api/name/connectedHost">&nbsp;&nbsp;&nbsp;&nbsp;- connectedHost</option>
	
	<option value="//api/name/connectedPort">&nbsp;&nbsp;&nbsp;&nbsp;- connectedPort</option>
	
	<option value="//api/name/delegate">&nbsp;&nbsp;&nbsp;&nbsp;- delegate</option>
	
	<option value="//api/name/delegateQueue">&nbsp;&nbsp;&nbsp;&nbsp;- delegateQueue</option>
	
	<option value="//api/name/enableBroadcast:error:">&nbsp;&nbsp;&nbsp;&nbsp;- enableBroadcast:error:</option>
	
	<option value="//api/name/getDelegate:delegateQueue:">&nbsp;&nbsp;&nbsp;&nbsp;- getDelegate:delegateQueue:</option>
	
	<option value="//api/name/init">&nbsp;&nbsp;&nbsp;&nbsp;- init</option>
	
	<option value="//api/name/initWithDelegate:delegateQueue:">&nbsp;&nbsp;&nbsp;&nbsp;- initWithDelegate:delegateQueue:</option>
	
	<option value="//api/name/initWithDelegate:delegateQueue:socketQueue:">&nbsp;&nbsp;&nbsp;&nbsp;- initWithDelegate:delegateQueue:socketQueue:</option>
	
	<option value="//api/name/initWithSocketQueue:">&nbsp;&nbsp;&nbsp;&nbsp;- initWithSocketQueue:</option>
	
	<option value="//api/name/isClosed">&nbsp;&nbsp;&nbsp;&nbsp;- isClosed</option>
	
	<option value="//api/name/isConnected">&nbsp;&nbsp;&nbsp;&nbsp;- isConnected</option>
	
	<option value="//api/name/isIPVersionNeutral">&nbsp;&nbsp;&nbsp;&nbsp;- isIPVersionNeutral</option>
	
	<option value="//api/name/isIPv4">&nbsp;&nbsp;&nbsp;&nbsp;- isIPv4</option>
	
	<option value="//api/name/isIPv4Enabled">&nbsp;&nbsp;&nbsp;&nbsp;- isIPv4Enabled</option>
	
	<option value="//api/name/isIPv4Preferred">&nbsp;&nbsp;&nbsp;&nbsp;- isIPv4Preferred</option>
	
	<option value="//api/name/isIPv6">&nbsp;&nbsp;&nbsp;&nbsp;- isIPv6</option>
	
	<option value="//api/name/isIPv6Enabled">&nbsp;&nbsp;&nbsp;&nbsp;- isIPv6Enabled</option>
	
	<option value="//api/name/isIPv6Preferred">&nbsp;&nbsp;&nbsp;&nbsp;- isIPv6Preferred</option>
	
	<option value="//api/name/joinMulticastGroup:error:">&nbsp;&nbsp;&nbsp;&nbsp;- joinMulticastGroup:error:</option>
	
	<option value="//api/name/joinMulticastGroup:onInterface:error:">&nbsp;&nbsp;&nbsp;&nbsp;- joinMulticastGroup:onInterface:error:</option>
	
	<option value="//api/name/leaveMulticastGroup:error:">&nbsp;&nbsp;&nbsp;&nbsp;- leaveMulticastGroup:error:</option>
	
	<option value="//api/name/leaveMulticastGroup:onInterface:error:">&nbsp;&nbsp;&nbsp;&nbsp;- leaveMulticastGroup:onInterface:error:</option>
	
	<option value="//api/name/localAddress">&nbsp;&nbsp;&nbsp;&nbsp;- localAddress</option>
	
	<option value="//api/name/localAddress_IPv4">&nbsp;&nbsp;&nbsp;&nbsp;- localAddress_IPv4</option>
	
	<option value="//api/name/localAddress_IPv6">&nbsp;&nbsp;&nbsp;&nbsp;- localAddress_IPv6</option>
	
	<option value="//api/name/localHost">&nbsp;&nbsp;&nbsp;&nbsp;- localHost</option>
	
	<option value="//api/name/localHost_IPv4">&nbsp;&nbsp;&nbsp;&nbsp;- localHost_IPv4</option>
	
	<option value="//api/name/localHost_IPv6">&nbsp;&nbsp;&nbsp;&nbsp;- localHost_IPv6</option>
	
	<option value="//api/name/localPort">&nbsp;&nbsp;&nbsp;&nbsp;- localPort</option>
	
	<option value="//api/name/localPort_IPv4">&nbsp;&nbsp;&nbsp;&nbsp;- localPort_IPv4</option>
	
	<option value="//api/name/localPort_IPv6">&nbsp;&nbsp;&nbsp;&nbsp;- localPort_IPv6</option>
	
	<option value="//api/name/maxReceiveIPv4BufferSize">&nbsp;&nbsp;&nbsp;&nbsp;- maxReceiveIPv4BufferSize</option>
	
	<option value="//api/name/maxReceiveIPv6BufferSize">&nbsp;&nbsp;&nbsp;&nbsp;- maxReceiveIPv6BufferSize</option>
	
	<option value="//api/name/pauseReceiving">&nbsp;&nbsp;&nbsp;&nbsp;- pauseReceiving</option>
	
	<option value="//api/name/performBlock:">&nbsp;&nbsp;&nbsp;&nbsp;- performBlock:</option>
	
	<option value="//api/name/readStream">&nbsp;&nbsp;&nbsp;&nbsp;- readStream</option>
	
	<option value="//api/name/receiveOnce:">&nbsp;&nbsp;&nbsp;&nbsp;- receiveOnce:</option>
	
	<option value="//api/name/sendData:toAddress:withTimeout:tag:">&nbsp;&nbsp;&nbsp;&nbsp;- sendData:toAddress:withTimeout:tag:</option>
	
	<option value="//api/name/sendData:toHost:port:withTimeout:tag:">&nbsp;&nbsp;&nbsp;&nbsp;- sendData:toHost:port:withTimeout:tag:</option>
	
	<option value="//api/name/sendData:withTimeout:tag:">&nbsp;&nbsp;&nbsp;&nbsp;- sendData:withTimeout:tag:</option>
	
	<option value="//api/name/setDelegate:">&nbsp;&nbsp;&nbsp;&nbsp;- setDelegate:</option>
	
	<option value="//api/name/setDelegate:delegateQueue:">&nbsp;&nbsp;&nbsp;&nbsp;- setDelegate:delegateQueue:</option>
	
	<option value="//api/name/setDelegateQueue:">&nbsp;&nbsp;&nbsp;&nbsp;- setDelegateQueue:</option>
	
	<option value="//api/name/setIPVersionNeutral">&nbsp;&nbsp;&nbsp;&nbsp;- setIPVersionNeutral</option>
	
	<option value="//api/name/setIPv4Enabled:">&nbsp;&nbsp;&nbsp;&nbsp;- setIPv4Enabled:</option>
	
	<option value="//api/name/setIPv6Enabled:">&nbsp;&nbsp;&nbsp;&nbsp;- setIPv6Enabled:</option>
	
	<option value="//api/name/setMaxReceiveIPv4BufferSize:">&nbsp;&nbsp;&nbsp;&nbsp;- setMaxReceiveIPv4BufferSize:</option>
	
	<option value="//api/name/setMaxReceiveIPv6BufferSize:">&nbsp;&nbsp;&nbsp;&nbsp;- setMaxReceiveIPv6BufferSize:</option>
	
	<option value="//api/name/setPreferIPv4">&nbsp;&nbsp;&nbsp;&nbsp;- setPreferIPv4</option>
	
	<option value="//api/name/setPreferIPv6">&nbsp;&nbsp;&nbsp;&nbsp;- setPreferIPv6</option>
	
	<option value="//api/name/setReceiveFilter:withQueue:">&nbsp;&nbsp;&nbsp;&nbsp;- setReceiveFilter:withQueue:</option>
	
	<option value="//api/name/setReceiveFilter:withQueue:isAsynchronous:">&nbsp;&nbsp;&nbsp;&nbsp;- setReceiveFilter:withQueue:isAsynchronous:</option>
	
	<option value="//api/name/setSendFilter:withQueue:">&nbsp;&nbsp;&nbsp;&nbsp;- setSendFilter:withQueue:</option>
	
	<option value="//api/name/setSendFilter:withQueue:isAsynchronous:">&nbsp;&nbsp;&nbsp;&nbsp;- setSendFilter:withQueue:isAsynchronous:</option>
	
	<option value="//api/name/setUserData:">&nbsp;&nbsp;&nbsp;&nbsp;- setUserData:</option>
	
	<option value="//api/name/socket4FD">&nbsp;&nbsp;&nbsp;&nbsp;- socket4FD</option>
	
	<option value="//api/name/socket6FD">&nbsp;&nbsp;&nbsp;&nbsp;- socket6FD</option>
	
	<option value="//api/name/socketFD">&nbsp;&nbsp;&nbsp;&nbsp;- socketFD</option>
	
	<option value="//api/name/synchronouslySetDelegate:">&nbsp;&nbsp;&nbsp;&nbsp;- synchronouslySetDelegate:</option>
	
	<option value="//api/name/synchronouslySetDelegate:delegateQueue:">&nbsp;&nbsp;&nbsp;&nbsp;- synchronouslySetDelegate:delegateQueue:</option>
	
	<option value="//api/name/synchronouslySetDelegateQueue:">&nbsp;&nbsp;&nbsp;&nbsp;- synchronouslySetDelegateQueue:</option>
	
	<option value="//api/name/userData">&nbsp;&nbsp;&nbsp;&nbsp;- userData</option>
	
	<option value="//api/name/writeStream">&nbsp;&nbsp;&nbsp;&nbsp;- writeStream</option>
	
	
	
</select>
				</li>
			</ul>
		</header>
		<nav id="tocContainer" class="isShowingTOC">
			<ul id="toc" role="tree">
				
<li role="treeitem"><span class="nodisclosure"></span><span class="sectionName"><a href="#overview">Overview</a></span></li>




<li role="treeitem" id="task_treeitem"><span class="nodisclosure"></span><span class="sectionName"><a href="#tasks">Tasks</a></span><ul>
	
</ul></li>







<li role="treeitem" class="children"><span class="disclosure"></span><span class="sectionName"><a href="#class_methods">Class Methods</a></span><ul>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/familyFromAddress:">familyFromAddress:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/getHost:port:family:fromAddress:">getHost:port:family:fromAddress:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/getHost:port:fromAddress:">getHost:port:fromAddress:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/hostFromAddress:">hostFromAddress:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/isIPv4Address:">isIPv4Address:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/isIPv6Address:">isIPv6Address:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/portFromAddress:">portFromAddress:</a></span></li>
	
</ul></li>



<li role="treeitem" class="children"><span class="disclosure"></span><span class="sectionName"><a href="#instance_methods">Instance Methods</a></span><ul>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/beginReceiving:">beginReceiving:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/bindToAddress:error:">bindToAddress:error:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/bindToPort:error:">bindToPort:error:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/bindToPort:interface:error:">bindToPort:interface:error:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/close">close</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/closeAfterSending">closeAfterSending</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/connectToAddress:error:">connectToAddress:error:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/connectToHost:onPort:error:">connectToHost:onPort:error:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/connectedAddress">connectedAddress</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/connectedHost">connectedHost</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/connectedPort">connectedPort</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/delegate">delegate</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/delegateQueue">delegateQueue</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/enableBroadcast:error:">enableBroadcast:error:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/getDelegate:delegateQueue:">getDelegate:delegateQueue:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/init">init</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/initWithDelegate:delegateQueue:">initWithDelegate:delegateQueue:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/initWithDelegate:delegateQueue:socketQueue:">initWithDelegate:delegateQueue:socketQueue:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/initWithSocketQueue:">initWithSocketQueue:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/isClosed">isClosed</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/isConnected">isConnected</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/isIPVersionNeutral">isIPVersionNeutral</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/isIPv4">isIPv4</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/isIPv4Enabled">isIPv4Enabled</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/isIPv4Preferred">isIPv4Preferred</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/isIPv6">isIPv6</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/isIPv6Enabled">isIPv6Enabled</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/isIPv6Preferred">isIPv6Preferred</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/joinMulticastGroup:error:">joinMulticastGroup:error:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/joinMulticastGroup:onInterface:error:">joinMulticastGroup:onInterface:error:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/leaveMulticastGroup:error:">leaveMulticastGroup:error:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/leaveMulticastGroup:onInterface:error:">leaveMulticastGroup:onInterface:error:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/localAddress">localAddress</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/localAddress_IPv4">localAddress_IPv4</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/localAddress_IPv6">localAddress_IPv6</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/localHost">localHost</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/localHost_IPv4">localHost_IPv4</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/localHost_IPv6">localHost_IPv6</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/localPort">localPort</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/localPort_IPv4">localPort_IPv4</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/localPort_IPv6">localPort_IPv6</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/maxReceiveIPv4BufferSize">maxReceiveIPv4BufferSize</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/maxReceiveIPv6BufferSize">maxReceiveIPv6BufferSize</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/pauseReceiving">pauseReceiving</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/performBlock:">performBlock:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/readStream">readStream</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/receiveOnce:">receiveOnce:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/sendData:toAddress:withTimeout:tag:">sendData:toAddress:withTimeout:tag:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/sendData:toHost:port:withTimeout:tag:">sendData:toHost:port:withTimeout:tag:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/sendData:withTimeout:tag:">sendData:withTimeout:tag:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setDelegate:">setDelegate:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setDelegate:delegateQueue:">setDelegate:delegateQueue:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setDelegateQueue:">setDelegateQueue:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setIPVersionNeutral">setIPVersionNeutral</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setIPv4Enabled:">setIPv4Enabled:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setIPv6Enabled:">setIPv6Enabled:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setMaxReceiveIPv4BufferSize:">setMaxReceiveIPv4BufferSize:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setMaxReceiveIPv6BufferSize:">setMaxReceiveIPv6BufferSize:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setPreferIPv4">setPreferIPv4</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setPreferIPv6">setPreferIPv6</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setReceiveFilter:withQueue:">setReceiveFilter:withQueue:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setReceiveFilter:withQueue:isAsynchronous:">setReceiveFilter:withQueue:isAsynchronous:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setSendFilter:withQueue:">setSendFilter:withQueue:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setSendFilter:withQueue:isAsynchronous:">setSendFilter:withQueue:isAsynchronous:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/setUserData:">setUserData:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/socket4FD">socket4FD</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/socket6FD">socket6FD</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/socketFD">socketFD</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/synchronouslySetDelegate:">synchronouslySetDelegate:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/synchronouslySetDelegate:delegateQueue:">synchronouslySetDelegate:delegateQueue:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/synchronouslySetDelegateQueue:">synchronouslySetDelegateQueue:</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/userData">userData</a></span></li>
	
	<li><span class="nodisclosure"></span><span class="sectionName"><a href="#//api/name/writeStream">writeStream</a></span></li>
	
</ul></li>


			</ul>
		</nav>
		<article>
			<div id="contents" class="isShowingTOC" role="main">
				<a title="GCDAsyncUdpSocket Class Reference" name="top"></a>
				<div class="main-navigation navigation-top">
					<ul>
	<li><a href="../index.html">Index</a></li>
	<li><a href="../hierarchy.html">Hierarchy</a></li>
</ul>
				</div>
				<div id="header">
					<div class="section-header">
						<h1 class="title title-header">GCDAsyncUdpSocket Class Reference</h1>
					</div>		
				</div>
				<div id="container">	
					
					<div class="section section-specification"><table cellspacing="0"><tbody>
						<tr>
	<td class="specification-title">Inherits from</td>
	<td class="specification-value">NSObject</td>
</tr><tr>
	<td class="specification-title">Declared in</td>
	<td class="specification-value">GCDAsyncUdpSocket.h</td>
</tr>
						</tbody></table></div>
					
					
					
					
					<div class="section section-overview">
						<a title="Overview" name="overview"></a>
						<h2 class="subtitle subtitle-overview">Overview</h2>
						<p>You may optionally set a send filter for the socket.<br/>
A filter can provide several interesting possibilities:</p>

<ol>
<li><p>Optional caching of resolved addresses for domain names.<br/>
The cache could later be consulted, resulting in fewer system calls to getaddrinfo.</p></li>
<li><p>Reusable modules of code for bandwidth monitoring.</p></li>
<li><p>Sometimes traffic shapers are needed to simulate real world environments.<br/>
A filter allows you to write custom code to simulate such environments.<br/>
The ability to code this yourself is especially helpful when your simulated environment<br/>
is more complicated than simple traffic shaping (e.g. simulating a cone port restricted router),<br/>
or the system tools to handle this aren&rsquo;t available (e.g. on a mobile device).</p></li>
</ol>

					</div>
					
					
					
					
					
					<div class="section section-tasks">
						<a title="Tasks" name="tasks"></a>
						<h2 class="subtitle subtitle-tasks">Tasks</h2>
						
						
						
						

						<ul class="task-list">
							<li>
	<span class="tooltip">
		<code><a href="#//api/name/init">&ndash;&nbsp;init</a></code>
		<span class="tooltip"><p>GCD<a href="../Classes/AsyncUdpSocket.html">AsyncUdpSocket</a> uses the standard <a href="#//api/name/delegate">delegate</a> paradigm,<br/>
but executes all <a href="#//api/name/delegate">delegate</a> callbacks on a given <a href="#//api/name/delegate">delegate</a> dispatch queue.<br/>
This allows for maximum concurrency, while at the same time providing easy thread safety.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/initWithSocketQueue:">&ndash;&nbsp;initWithSocketQueue:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/initWithDelegate:delegateQueue:">&ndash;&nbsp;initWithDelegate:delegateQueue:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/initWithDelegate:delegateQueue:socketQueue:">&ndash;&nbsp;initWithDelegate:delegateQueue:socketQueue:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/delegate">&ndash;&nbsp;delegate</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setDelegate:">&ndash;&nbsp;setDelegate:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/synchronouslySetDelegate:">&ndash;&nbsp;synchronouslySetDelegate:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/delegateQueue">&ndash;&nbsp;delegateQueue</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setDelegateQueue:">&ndash;&nbsp;setDelegateQueue:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/synchronouslySetDelegateQueue:">&ndash;&nbsp;synchronouslySetDelegateQueue:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/getDelegate:delegateQueue:">&ndash;&nbsp;getDelegate:delegateQueue:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setDelegate:delegateQueue:">&ndash;&nbsp;setDelegate:delegateQueue:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/synchronouslySetDelegate:delegateQueue:">&ndash;&nbsp;synchronouslySetDelegate:delegateQueue:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/isIPv4Enabled">&ndash;&nbsp;isIPv4Enabled</a></code>
		<span class="tooltip"><p>By default, both IPv4 and IPv6 are enabled.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setIPv4Enabled:">&ndash;&nbsp;setIPv4Enabled:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/isIPv6Enabled">&ndash;&nbsp;isIPv6Enabled</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setIPv6Enabled:">&ndash;&nbsp;setIPv6Enabled:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/isIPv4Preferred">&ndash;&nbsp;isIPv4Preferred</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/isIPv6Preferred">&ndash;&nbsp;isIPv6Preferred</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/isIPVersionNeutral">&ndash;&nbsp;isIPVersionNeutral</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setPreferIPv4">&ndash;&nbsp;setPreferIPv4</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setPreferIPv6">&ndash;&nbsp;setPreferIPv6</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setIPVersionNeutral">&ndash;&nbsp;setIPVersionNeutral</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/maxReceiveIPv4BufferSize">&ndash;&nbsp;maxReceiveIPv4BufferSize</a></code>
		<span class="tooltip"><p>Gets/Sets the maximum size of the buffer that will be allocated for receive operations.<br/>
The default maximum size is 9216 bytes.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setMaxReceiveIPv4BufferSize:">&ndash;&nbsp;setMaxReceiveIPv4BufferSize:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/maxReceiveIPv6BufferSize">&ndash;&nbsp;maxReceiveIPv6BufferSize</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setMaxReceiveIPv6BufferSize:">&ndash;&nbsp;setMaxReceiveIPv6BufferSize:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/userData">&ndash;&nbsp;userData</a></code>
		<span class="tooltip"><p>User data allows you to associate arbitrary information with the socket.<br/>
This data is not used internally in any way.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setUserData:">&ndash;&nbsp;setUserData:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/localAddress">&ndash;&nbsp;localAddress</a></code>
		<span class="tooltip"><p>Returns the local address info for the socket.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/localHost">&ndash;&nbsp;localHost</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/localPort">&ndash;&nbsp;localPort</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/localAddress_IPv4">&ndash;&nbsp;localAddress_IPv4</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/localHost_IPv4">&ndash;&nbsp;localHost_IPv4</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/localPort_IPv4">&ndash;&nbsp;localPort_IPv4</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/localAddress_IPv6">&ndash;&nbsp;localAddress_IPv6</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/localHost_IPv6">&ndash;&nbsp;localHost_IPv6</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/localPort_IPv6">&ndash;&nbsp;localPort_IPv6</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/connectedAddress">&ndash;&nbsp;connectedAddress</a></code>
		<span class="tooltip"><p>Returns the remote address info for the socket.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/connectedHost">&ndash;&nbsp;connectedHost</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/connectedPort">&ndash;&nbsp;connectedPort</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/isConnected">&ndash;&nbsp;isConnected</a></code>
		<span class="tooltip"><p>Returns whether or not this socket has been connected to a single host.<br/>
By design, UDP is a connectionless protocol, and connecting is not needed.<br/>
If connected, the socket will only be able to send/receive data to/from the connected host.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/isClosed">&ndash;&nbsp;isClosed</a></code>
		<span class="tooltip"><p>Returns whether or not this socket has been closed.<br/>
The only way a socket can be closed is if you explicitly call one of the <a href="#//api/name/close">close</a> methods.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/isIPv4">&ndash;&nbsp;isIPv4</a></code>
		<span class="tooltip"><p>Returns whether or not this socket is IPv4.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/isIPv6">&ndash;&nbsp;isIPv6</a></code>
		<span class="tooltip"><p>Returns whether or not this socket is IPv6.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/bindToPort:error:">&ndash;&nbsp;bindToPort:error:</a></code>
		<span class="tooltip"><p>Binds the UDP socket to the given port.<br/>
Binding should be done for server sockets that receive data prior to sending it.<br/>
Client sockets can skip binding,<br/>
as the OS will automatically assign the socket an available port when it starts sending data.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/bindToPort:interface:error:">&ndash;&nbsp;bindToPort:interface:error:</a></code>
		<span class="tooltip"><p>Binds the UDP socket to the given port and optional interface.<br/>
Binding should be done for server sockets that receive data prior to sending it.<br/>
Client sockets can skip binding,<br/>
as the OS will automatically assign the socket an available port when it starts sending data.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/bindToAddress:error:">&ndash;&nbsp;bindToAddress:error:</a></code>
		<span class="tooltip"><p>Binds the UDP socket to the given address, specified as a sockaddr structure wrapped in a NSData object.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/connectToHost:onPort:error:">&ndash;&nbsp;connectToHost:onPort:error:</a></code>
		<span class="tooltip"><p>Connects the UDP socket to the given host and port.<br/>
By design, UDP is a connectionless protocol, and connecting is not needed.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/connectToAddress:error:">&ndash;&nbsp;connectToAddress:error:</a></code>
		<span class="tooltip"><p>Connects the UDP socket to the given address, specified as a sockaddr structure wrapped in a NSData object.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/joinMulticastGroup:error:">&ndash;&nbsp;joinMulticastGroup:error:</a></code>
		<span class="tooltip"><p>Join multicast group.<br/>
Group should be an IP address (eg @&ldquo;225.228.0.1&rdquo;).</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/joinMulticastGroup:onInterface:error:">&ndash;&nbsp;joinMulticastGroup:onInterface:error:</a></code>
		<span class="tooltip"><p>Join multicast group.<br/>
Group should be an IP address (eg @&ldquo;225.228.0.1&rdquo;).<br/>
The interface may be a name (e.g. &ldquo;en1&rdquo; or &ldquo;lo0&rdquo;) or the corresponding IP address (e.g. &ldquo;192.168.4.35&rdquo;).</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/leaveMulticastGroup:error:">&ndash;&nbsp;leaveMulticastGroup:error:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/leaveMulticastGroup:onInterface:error:">&ndash;&nbsp;leaveMulticastGroup:onInterface:error:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/enableBroadcast:error:">&ndash;&nbsp;enableBroadcast:error:</a></code>
		<span class="tooltip"><p>By default, the underlying socket in the OS will not allow you to send broadcast messages.<br/>
In order to send broadcast messages, you need to enable this functionality in the socket.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/sendData:withTimeout:tag:">&ndash;&nbsp;sendData:withTimeout:tag:</a></code>
		<span class="tooltip"><p>Asynchronously sends the given data, with the given timeout and tag.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/sendData:toHost:port:withTimeout:tag:">&ndash;&nbsp;sendData:toHost:port:withTimeout:tag:</a></code>
		<span class="tooltip"><p>Asynchronously sends the given data, with the given timeout and tag, to the given host and port.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/sendData:toAddress:withTimeout:tag:">&ndash;&nbsp;sendData:toAddress:withTimeout:tag:</a></code>
		<span class="tooltip"><p>Asynchronously sends the given data, with the given timeout and tag, to the given address.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setSendFilter:withQueue:">&ndash;&nbsp;setSendFilter:withQueue:</a></code>
		<span class="tooltip"><p>You may optionally set a send filter for the socket.<br/>
A filter can provide several interesting possibilities:</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setSendFilter:withQueue:isAsynchronous:">&ndash;&nbsp;setSendFilter:withQueue:isAsynchronous:</a></code>
		<span class="tooltip"><p>The receive filter can be run via dispatch_async or dispatch_sync.<br/>
Most typical situations call for asynchronous operation.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/receiveOnce:">&ndash;&nbsp;receiveOnce:</a></code>
		<span class="tooltip"><p>There are two modes of operation for receiving packets: one-at-a-time &amp; continuous.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/beginReceiving:">&ndash;&nbsp;beginReceiving:</a></code>
		<span class="tooltip"><p>There are two modes of operation for receiving packets: one-at-a-time &amp; continuous.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/pauseReceiving">&ndash;&nbsp;pauseReceiving</a></code>
		<span class="tooltip"><p>If the socket is currently receiving (beginReceiving has been called), this method pauses the receiving.<br/>
That is, it won&rsquo;t read any more packets from the underlying OS socket until beginReceiving is called again.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setReceiveFilter:withQueue:">&ndash;&nbsp;setReceiveFilter:withQueue:</a></code>
		<span class="tooltip"><p>You may optionally set a receive filter for the socket.<br/>
This receive filter may be set to run in its own queue (independent of <a href="#//api/name/delegate">delegate</a> queue).</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/setReceiveFilter:withQueue:isAsynchronous:">&ndash;&nbsp;setReceiveFilter:withQueue:isAsynchronous:</a></code>
		<span class="tooltip"><p>The receive filter can be run via dispatch_async or dispatch_sync.<br/>
Most typical situations call for asynchronous operation.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/close">&ndash;&nbsp;close</a></code>
		<span class="tooltip"><p>Immediately closes the underlying socket.<br/>
Any pending send operations are discarded.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/closeAfterSending">&ndash;&nbsp;closeAfterSending</a></code>
		<span class="tooltip"><p>Closes the underlying socket after all pending send operations have been sent.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/performBlock:">&ndash;&nbsp;performBlock:</a></code>
		<span class="tooltip"><p>It&rsquo;s not thread-safe to access certain variables from outside the socket&rsquo;s internal queue.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/socketFD">&ndash;&nbsp;socketFD</a></code>
		<span class="tooltip"><p>These methods are only available from within the context of a <a href="#//api/name/performBlock:">performBlock:</a> invocation.<br/>
See the documentation for the <a href="#//api/name/performBlock:">performBlock:</a> method above.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/socket4FD">&ndash;&nbsp;socket4FD</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/socket6FD">&ndash;&nbsp;socket6FD</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/readStream">&ndash;&nbsp;readStream</a></code>
		<span class="tooltip"><p>These methods are only available from within the context of a <a href="#//api/name/performBlock:">performBlock:</a> invocation.<br/>
See the documentation for the <a href="#//api/name/performBlock:">performBlock:</a> method above.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/writeStream">&ndash;&nbsp;writeStream</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/hostFromAddress:">+&nbsp;hostFromAddress:</a></code>
		<span class="tooltip"><p>Extracting host/port/family information from raw address data.</p></span>
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/portFromAddress:">+&nbsp;portFromAddress:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/familyFromAddress:">+&nbsp;familyFromAddress:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/isIPv4Address:">+&nbsp;isIPv4Address:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/isIPv6Address:">+&nbsp;isIPv6Address:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/getHost:port:fromAddress:">+&nbsp;getHost:port:fromAddress:</a></code>
		
	</span>
	
	
</li><li>
	<span class="tooltip">
		<code><a href="#//api/name/getHost:port:family:fromAddress:">+&nbsp;getHost:port:family:fromAddress:</a></code>
		
	</span>
	
	
</li>
						</ul>
						
					</div>
					
					
					
					
					
					
					
					<div class="section section-methods">
						<a title="Class Methods" name="class_methods"></a>
						<h2 class="subtitle subtitle-methods">Class Methods</h2>
						
						<div class="section-method">
	<a name="//api/name/familyFromAddress:" title="familyFromAddress:"></a>
	<h3 class="subsubtitle method-title">familyFromAddress:</h3>
	
	

	<div class="method-subsection method-declaration"><code>+ (int)familyFromAddress:(NSData *)<em>address</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/getHost:port:family:fromAddress:" title="getHost:port:family:fromAddress:"></a>
	<h3 class="subsubtitle method-title">getHost:port:family:fromAddress:</h3>
	
	

	<div class="method-subsection method-declaration"><code>+ (BOOL)getHost:(NSString **)<em>hostPtr</em> port:(uint16_t *)<em>portPtr</em> family:(int *)<em>afPtr</em> fromAddress:(NSData *)<em>address</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/getHost:port:fromAddress:" title="getHost:port:fromAddress:"></a>
	<h3 class="subsubtitle method-title">getHost:port:fromAddress:</h3>
	
	

	<div class="method-subsection method-declaration"><code>+ (BOOL)getHost:(NSString **)<em>hostPtr</em> port:(uint16_t *)<em>portPtr</em> fromAddress:(NSData *)<em>address</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/hostFromAddress:" title="hostFromAddress:"></a>
	<h3 class="subsubtitle method-title">hostFromAddress:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Extracting host/port/family information from raw address data.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>+ (NSString *)hostFromAddress:(NSData *)<em>address</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Extracting host/port/family information from raw address data.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/isIPv4Address:" title="isIPv4Address:"></a>
	<h3 class="subsubtitle method-title">isIPv4Address:</h3>
	
	

	<div class="method-subsection method-declaration"><code>+ (BOOL)isIPv4Address:(NSData *)<em>address</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/isIPv6Address:" title="isIPv6Address:"></a>
	<h3 class="subsubtitle method-title">isIPv6Address:</h3>
	
	

	<div class="method-subsection method-declaration"><code>+ (BOOL)isIPv6Address:(NSData *)<em>address</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/portFromAddress:" title="portFromAddress:"></a>
	<h3 class="subsubtitle method-title">portFromAddress:</h3>
	
	

	<div class="method-subsection method-declaration"><code>+ (uint16_t)portFromAddress:(NSData *)<em>address</em></code></div>

    
</div>
						
					</div>
					
					
					
					<div class="section section-methods">
						<a title="Instance Methods" name="instance_methods"></a>
						<h2 class="subtitle subtitle-methods">Instance Methods</h2>
						
						<div class="section-method">
	<a name="//api/name/beginReceiving:" title="beginReceiving:"></a>
	<h3 class="subsubtitle method-title">beginReceiving:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>There are two modes of operation for receiving packets: one-at-a-time &amp; continuous.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)beginReceiving:(NSError **)<em>errPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>There are two modes of operation for receiving packets: one-at-a-time &amp; continuous.</p>

<p>In one-at-a-time mode, you call receiveOnce everytime your <a href="#//api/name/delegate">delegate</a> is ready to process an incoming udp packet.<br/>
Receiving packets one-at-a-time may be better suited for implementing certain state machine code,<br/>
where your state machine may not always be ready to process incoming packets.</p>

<p>In continuous mode, the <a href="#//api/name/delegate">delegate</a> is invoked immediately everytime incoming udp packets are received.<br/>
Receiving packets continuously is better suited to real-time streaming applications.</p>

<p>You may switch back and forth between one-at-a-time mode and continuous mode.<br/>
If the socket is currently in one-at-a-time mode, calling this method will switch it to continuous mode.</p>

<p>For every received packet (not filtered by the optional receive filter),<br/>
the <a href="#//api/name/delegate">delegate</a> method (udpSocket:didReceiveData:fromAddress:withFilterContext:) is invoked.</p>

<p>If the socket is able to begin receiving packets, this method returns YES.<br/>
Otherwise it returns NO, and sets the errPtr with appropriate error information.</p>

<p>An example error:<br/>
You created a udp socket to act as a server, and immediately called receive.<br/>
You forgot to first bind the socket to a port number, and received a error with a message like:<br/>
&ldquo;Must bind socket before you can receive data.&rdquo;</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/bindToAddress:error:" title="bindToAddress:error:"></a>
	<h3 class="subsubtitle method-title">bindToAddress:error:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Binds the UDP socket to the given address, specified as a sockaddr structure wrapped in a NSData object.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)bindToAddress:(NSData *)<em>localAddr</em> error:(NSError **)<em>errPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Binds the UDP socket to the given address, specified as a sockaddr structure wrapped in a NSData object.</p>

<p>If you have an existing struct sockaddr you can convert it to a NSData object like so:<br/>
struct sockaddr sa  -> NSData <em>dsa = [NSData dataWithBytes:&amp;remoteAddr length:remoteAddr.sa_len];<br/>
struct sockaddr </em>sa -> NSData *dsa = [NSData dataWithBytes:remoteAddr length:remoteAddr->sa_len];</p>

<p>Binding should be done for server sockets that receive data prior to sending it.<br/>
Client sockets can skip binding,<br/>
as the OS will automatically assign the socket an available port when it starts sending data.</p>

<p>You cannot bind a socket after its been connected.<br/>
You can only bind a socket once.<br/>
You can still connect a socket (if desired) after binding.</p>

<p>On success, returns YES.<br/>
Otherwise returns NO, and sets errPtr. If you don&rsquo;t care about the error, you can pass NULL for errPtr.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/bindToPort:error:" title="bindToPort:error:"></a>
	<h3 class="subsubtitle method-title">bindToPort:error:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Binds the UDP socket to the given port.<br/>
Binding should be done for server sockets that receive data prior to sending it.<br/>
Client sockets can skip binding,<br/>
as the OS will automatically assign the socket an available port when it starts sending data.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)bindToPort:(uint16_t)<em>port</em> error:(NSError **)<em>errPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Binds the UDP socket to the given port.<br/>
Binding should be done for server sockets that receive data prior to sending it.<br/>
Client sockets can skip binding,<br/>
as the OS will automatically assign the socket an available port when it starts sending data.</p>

<p>You may optionally pass a port number of zero to immediately bind the socket,<br/>
yet still allow the OS to automatically assign an available port.</p>

<p>You cannot bind a socket after its been connected.<br/>
You can only bind a socket once.<br/>
You can still connect a socket (if desired) after binding.</p>

<p>On success, returns YES.<br/>
Otherwise returns NO, and sets errPtr. If you don&rsquo;t care about the error, you can pass NULL for errPtr.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/bindToPort:interface:error:" title="bindToPort:interface:error:"></a>
	<h3 class="subsubtitle method-title">bindToPort:interface:error:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Binds the UDP socket to the given port and optional interface.<br/>
Binding should be done for server sockets that receive data prior to sending it.<br/>
Client sockets can skip binding,<br/>
as the OS will automatically assign the socket an available port when it starts sending data.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)bindToPort:(uint16_t)<em>port</em> interface:(NSString *)<em>interface</em> error:(NSError **)<em>errPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Binds the UDP socket to the given port and optional interface.<br/>
Binding should be done for server sockets that receive data prior to sending it.<br/>
Client sockets can skip binding,<br/>
as the OS will automatically assign the socket an available port when it starts sending data.</p>

<p>You may optionally pass a port number of zero to immediately bind the socket,<br/>
yet still allow the OS to automatically assign an available port.</p>

<p>The interface may be a name (e.g. &ldquo;en1&rdquo; or &ldquo;lo0&rdquo;) or the corresponding IP address (e.g. &ldquo;192.168.4.35&rdquo;).<br/>
You may also use the special strings &ldquo;localhost&rdquo; or &ldquo;loopback&rdquo; to specify that<br/>
the socket only accept packets from the local machine.</p>

<p>You cannot bind a socket after its been connected.<br/>
You can only bind a socket once.<br/>
You can still connect a socket (if desired) after binding.</p>

<p>On success, returns YES.<br/>
Otherwise returns NO, and sets errPtr. If you don&rsquo;t care about the error, you can pass NULL for errPtr.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/close" title="close"></a>
	<h3 class="subsubtitle method-title">close</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Immediately closes the underlying socket.<br/>
Any pending send operations are discarded.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)close</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Immediately closes the underlying socket.<br/>
Any pending send operations are discarded.</p>

<p>The GCD<a href="../Classes/AsyncUdpSocket.html">AsyncUdpSocket</a> instance may optionally be used again.<br/>
(it will setup/configure/use another unnderlying BSD socket).</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/closeAfterSending" title="closeAfterSending"></a>
	<h3 class="subsubtitle method-title">closeAfterSending</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Closes the underlying socket after all pending send operations have been sent.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)closeAfterSending</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Closes the underlying socket after all pending send operations have been sent.</p>

<p>The GCD<a href="../Classes/AsyncUdpSocket.html">AsyncUdpSocket</a> instance may optionally be used again.<br/>
(it will setup/configure/use another unnderlying BSD socket).</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/connectToAddress:error:" title="connectToAddress:error:"></a>
	<h3 class="subsubtitle method-title">connectToAddress:error:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Connects the UDP socket to the given address, specified as a sockaddr structure wrapped in a NSData object.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)connectToAddress:(NSData *)<em>remoteAddr</em> error:(NSError **)<em>errPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Connects the UDP socket to the given address, specified as a sockaddr structure wrapped in a NSData object.</p>

<p>If you have an existing struct sockaddr you can convert it to a NSData object like so:<br/>
struct sockaddr sa  -> NSData <em>dsa = [NSData dataWithBytes:&amp;remoteAddr length:remoteAddr.sa_len];<br/>
struct sockaddr </em>sa -> NSData *dsa = [NSData dataWithBytes:remoteAddr length:remoteAddr->sa_len];</p>

<p>By design, UDP is a connectionless protocol, and connecting is not needed.</p>

<p>Choosing to connect to a specific address has the following effect:<br/>
- You will only be able to send data to the connected address.<br/>
- You will only be able to receive data from the connected address.<br/>
- You will receive ICMP messages that come from the connected address, such as &ldquo;connection refused&rdquo;.</p>

<p>Connecting a UDP socket does not result in any communication on the socket.<br/>
It simply changes the internal state of the socket.</p>

<p>You cannot bind a socket after its been connected.<br/>
You can only connect a socket once.</p>

<p>On success, returns YES.<br/>
Otherwise returns NO, and sets errPtr. If you don&rsquo;t care about the error, you can pass nil for errPtr.</p>

<p>Note: Unlike the <a href="#//api/name/connectToHost:onPort:error:">connectToHost:onPort:error:</a> method, this method does not require a DNS lookup.<br/>
Thus when this method returns, the connection has either failed or fully completed.<br/>
In other words, this method is synchronous, unlike the asynchronous connectToHost::: method.<br/>
However, for compatibility and simplification of <a href="#//api/name/delegate">delegate</a> code, if this method returns YES<br/>
then the corresponding <a href="#//api/name/delegate">delegate</a> method (udpSocket:didConnectToHost:port:) is still invoked.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/connectToHost:onPort:error:" title="connectToHost:onPort:error:"></a>
	<h3 class="subsubtitle method-title">connectToHost:onPort:error:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Connects the UDP socket to the given host and port.<br/>
By design, UDP is a connectionless protocol, and connecting is not needed.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)connectToHost:(NSString *)<em>host</em> onPort:(uint16_t)<em>port</em> error:(NSError **)<em>errPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Connects the UDP socket to the given host and port.<br/>
By design, UDP is a connectionless protocol, and connecting is not needed.</p>

<p>Choosing to connect to a specific host/port has the following effect:<br/>
- You will only be able to send data to the connected host/port.<br/>
- You will only be able to receive data from the connected host/port.<br/>
- You will receive ICMP messages that come from the connected host/port, such as &ldquo;connection refused&rdquo;.</p>

<p>The actual process of connecting a UDP socket does not result in any communication on the socket.<br/>
It simply changes the internal state of the socket.</p>

<p>You cannot bind a socket after it has been connected.<br/>
You can only connect a socket once.</p>

<p>The host may be a domain name (e.g. &ldquo;deusty.com&rdquo;) or an IP address string (e.g. &ldquo;192.168.0.2&rdquo;).</p>

<p>This method is asynchronous as it requires a DNS lookup to resolve the given host name.<br/>
If an obvious error is detected, this method immediately returns NO and sets errPtr.<br/>
If you don&rsquo;t care about the error, you can pass nil for errPtr.<br/>
Otherwise, this method returns YES and begins the asynchronous connection process.<br/>
The result of the asynchronous connection process will be reported via the <a href="#//api/name/delegate">delegate</a> methods.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/connectedAddress" title="connectedAddress"></a>
	<h3 class="subsubtitle method-title">connectedAddress</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Returns the remote address info for the socket.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (NSData *)connectedAddress</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Returns the remote address info for the socket.</p>

<p>The connectedAddress method returns a sockaddr structure wrapped in a NSData object.<br/>
The <a href="#//api/name/connectedHost">connectedHost</a> method returns the human readable IP address as a string.</p>

<p>Note: Since UDP is connectionless by design, connected address info<br/>
will not be available unless the socket is explicitly connected to a remote host/port.<br/>
If the socket is not connected, these methods will return nil / 0.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/connectedHost" title="connectedHost"></a>
	<h3 class="subsubtitle method-title">connectedHost</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (NSString *)connectedHost</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/connectedPort" title="connectedPort"></a>
	<h3 class="subsubtitle method-title">connectedPort</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (uint16_t)connectedPort</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/delegate" title="delegate"></a>
	<h3 class="subsubtitle method-title">delegate</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (id)delegate</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/delegateQueue" title="delegateQueue"></a>
	<h3 class="subsubtitle method-title">delegateQueue</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (dispatch_queue_t)delegateQueue</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/enableBroadcast:error:" title="enableBroadcast:error:"></a>
	<h3 class="subsubtitle method-title">enableBroadcast:error:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>By default, the underlying socket in the OS will not allow you to send broadcast messages.<br/>
In order to send broadcast messages, you need to enable this functionality in the socket.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)enableBroadcast:(BOOL)<em>flag</em> error:(NSError **)<em>errPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>By default, the underlying socket in the OS will not allow you to send broadcast messages.<br/>
In order to send broadcast messages, you need to enable this functionality in the socket.</p>

<p>A broadcast is a UDP message to addresses like &ldquo;192.168.255.255&rdquo; or &ldquo;255.255.255.255&rdquo; that is<br/>
delivered to every host on the network.<br/>
The reason this is generally disabled by default (by the OS) is to prevent<br/>
accidental broadcast messages from flooding the network.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/getDelegate:delegateQueue:" title="getDelegate:delegateQueue:"></a>
	<h3 class="subsubtitle method-title">getDelegate:delegateQueue:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)getDelegate:(id *)<em>delegatePtr</em> delegateQueue:(dispatch_queue_t *)<em>delegateQueuePtr</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/init" title="init"></a>
	<h3 class="subsubtitle method-title">init</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>GCD<a href="../Classes/AsyncUdpSocket.html">AsyncUdpSocket</a> uses the standard <a href="#//api/name/delegate">delegate</a> paradigm,<br/>
but executes all <a href="#//api/name/delegate">delegate</a> callbacks on a given <a href="#//api/name/delegate">delegate</a> dispatch queue.<br/>
This allows for maximum concurrency, while at the same time providing easy thread safety.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (id)init</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>GCD<a href="../Classes/AsyncUdpSocket.html">AsyncUdpSocket</a> uses the standard <a href="#//api/name/delegate">delegate</a> paradigm,<br/>
but executes all <a href="#//api/name/delegate">delegate</a> callbacks on a given <a href="#//api/name/delegate">delegate</a> dispatch queue.<br/>
This allows for maximum concurrency, while at the same time providing easy thread safety.</p>

<p>You MUST set a <a href="#//api/name/delegate">delegate</a> AND <a href="#//api/name/delegate">delegate</a> dispatch queue before attempting to<br/>
use the socket, or you will get an error.</p>

<p>The socket queue is optional.<br/>
If you pass NULL, <a href="../Classes/GCDAsyncSocket.html">GCDAsyncSocket</a> will automatically create its own socket queue.<br/>
If you choose to provide a socket queue, the socket queue must not be a concurrent queue.</p>

<p>The <a href="#//api/name/delegate">delegate</a> queue and socket queue can optionally be the same.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/initWithDelegate:delegateQueue:" title="initWithDelegate:delegateQueue:"></a>
	<h3 class="subsubtitle method-title">initWithDelegate:delegateQueue:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (id)initWithDelegate:(id)<em>aDelegate</em> delegateQueue:(dispatch_queue_t)<em>dq</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/initWithDelegate:delegateQueue:socketQueue:" title="initWithDelegate:delegateQueue:socketQueue:"></a>
	<h3 class="subsubtitle method-title">initWithDelegate:delegateQueue:socketQueue:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (id)initWithDelegate:(id)<em>aDelegate</em> delegateQueue:(dispatch_queue_t)<em>dq</em> socketQueue:(dispatch_queue_t)<em>sq</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/initWithSocketQueue:" title="initWithSocketQueue:"></a>
	<h3 class="subsubtitle method-title">initWithSocketQueue:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (id)initWithSocketQueue:(dispatch_queue_t)<em>sq</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/isClosed" title="isClosed"></a>
	<h3 class="subsubtitle method-title">isClosed</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Returns whether or not this socket has been closed.<br/>
The only way a socket can be closed is if you explicitly call one of the <a href="#//api/name/close">close</a> methods.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)isClosed</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Returns whether or not this socket has been closed.<br/>
The only way a socket can be closed is if you explicitly call one of the <a href="#//api/name/close">close</a> methods.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/isConnected" title="isConnected"></a>
	<h3 class="subsubtitle method-title">isConnected</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Returns whether or not this socket has been connected to a single host.<br/>
By design, UDP is a connectionless protocol, and connecting is not needed.<br/>
If connected, the socket will only be able to send/receive data to/from the connected host.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)isConnected</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Returns whether or not this socket has been connected to a single host.<br/>
By design, UDP is a connectionless protocol, and connecting is not needed.<br/>
If connected, the socket will only be able to send/receive data to/from the connected host.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/isIPVersionNeutral" title="isIPVersionNeutral"></a>
	<h3 class="subsubtitle method-title">isIPVersionNeutral</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (BOOL)isIPVersionNeutral</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/isIPv4" title="isIPv4"></a>
	<h3 class="subsubtitle method-title">isIPv4</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Returns whether or not this socket is IPv4.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)isIPv4</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Returns whether or not this socket is IPv4.</p>

<p>By default this will be true, unless:<br/>
- IPv4 is disabled (via <a href="#//api/name/setIPv4Enabled:">setIPv4Enabled:</a>)<br/>
- The socket is explicitly bound to an IPv6 address<br/>
- The socket is connected to an IPv6 address</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/isIPv4Enabled" title="isIPv4Enabled"></a>
	<h3 class="subsubtitle method-title">isIPv4Enabled</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>By default, both IPv4 and IPv6 are enabled.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)isIPv4Enabled</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>By default, both IPv4 and IPv6 are enabled.</p>

<p>This means GCD<a href="../Classes/AsyncUdpSocket.html">AsyncUdpSocket</a> automatically supports both protocols,<br/>
and can send to IPv4 or IPv6 addresses,<br/>
as well as receive over IPv4 and IPv6.</p>

<p>For operations that require DNS resolution, GCD<a href="../Classes/AsyncUdpSocket.html">AsyncUdpSocket</a> supports both IPv4 and IPv6.<br/>
If a DNS lookup returns only IPv4 results, GCD<a href="../Classes/AsyncUdpSocket.html">AsyncUdpSocket</a> will automatically use IPv4.<br/>
If a DNS lookup returns only IPv6 results, GCD<a href="../Classes/AsyncUdpSocket.html">AsyncUdpSocket</a> will automatically use IPv6.<br/>
If a DNS lookup returns both IPv4 and IPv6 results, then the protocol used depends on the configured preference.<br/>
If IPv4 is preferred, then IPv4 is used.<br/>
If IPv6 is preferred, then IPv6 is used.<br/>
If neutral, then the first IP version in the resolved array will be used.</p>

<p>Starting with Mac OS X 10.7 Lion and iOS 5, the default IP preference is neutral.<br/>
On prior systems the default IP preference is IPv4.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/isIPv4Preferred" title="isIPv4Preferred"></a>
	<h3 class="subsubtitle method-title">isIPv4Preferred</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (BOOL)isIPv4Preferred</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/isIPv6" title="isIPv6"></a>
	<h3 class="subsubtitle method-title">isIPv6</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Returns whether or not this socket is IPv6.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)isIPv6</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Returns whether or not this socket is IPv6.</p>

<p>By default this will be true, unless:<br/>
- IPv6 is disabled (via <a href="#//api/name/setIPv6Enabled:">setIPv6Enabled:</a>)<br/>
- The socket is explicitly bound to an IPv4 address<br/>
_ The socket is connected to an IPv4 address</p>

<p>This method will also return false on platforms that do not support IPv6.<br/>
Note: The iPhone does not currently support IPv6.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/isIPv6Enabled" title="isIPv6Enabled"></a>
	<h3 class="subsubtitle method-title">isIPv6Enabled</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (BOOL)isIPv6Enabled</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/isIPv6Preferred" title="isIPv6Preferred"></a>
	<h3 class="subsubtitle method-title">isIPv6Preferred</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (BOOL)isIPv6Preferred</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/joinMulticastGroup:error:" title="joinMulticastGroup:error:"></a>
	<h3 class="subsubtitle method-title">joinMulticastGroup:error:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Join multicast group.<br/>
Group should be an IP address (eg @&ldquo;225.228.0.1&rdquo;).</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)joinMulticastGroup:(NSString *)<em>group</em> error:(NSError **)<em>errPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Join multicast group.<br/>
Group should be an IP address (eg @&ldquo;225.228.0.1&rdquo;).</p>

<p>On success, returns YES.<br/>
Otherwise returns NO, and sets errPtr. If you don&rsquo;t care about the error, you can pass nil for errPtr.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/joinMulticastGroup:onInterface:error:" title="joinMulticastGroup:onInterface:error:"></a>
	<h3 class="subsubtitle method-title">joinMulticastGroup:onInterface:error:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Join multicast group.<br/>
Group should be an IP address (eg @&ldquo;225.228.0.1&rdquo;).<br/>
The interface may be a name (e.g. &ldquo;en1&rdquo; or &ldquo;lo0&rdquo;) or the corresponding IP address (e.g. &ldquo;192.168.4.35&rdquo;).</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)joinMulticastGroup:(NSString *)<em>group</em> onInterface:(NSString *)<em>interface</em> error:(NSError **)<em>errPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Join multicast group.<br/>
Group should be an IP address (eg @&ldquo;225.228.0.1&rdquo;).<br/>
The interface may be a name (e.g. &ldquo;en1&rdquo; or &ldquo;lo0&rdquo;) or the corresponding IP address (e.g. &ldquo;192.168.4.35&rdquo;).</p>

<p>On success, returns YES.<br/>
Otherwise returns NO, and sets errPtr. If you don&rsquo;t care about the error, you can pass nil for errPtr.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/leaveMulticastGroup:error:" title="leaveMulticastGroup:error:"></a>
	<h3 class="subsubtitle method-title">leaveMulticastGroup:error:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (BOOL)leaveMulticastGroup:(NSString *)<em>group</em> error:(NSError **)<em>errPtr</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/leaveMulticastGroup:onInterface:error:" title="leaveMulticastGroup:onInterface:error:"></a>
	<h3 class="subsubtitle method-title">leaveMulticastGroup:onInterface:error:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (BOOL)leaveMulticastGroup:(NSString *)<em>group</em> onInterface:(NSString *)<em>interface</em> error:(NSError **)<em>errPtr</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/localAddress" title="localAddress"></a>
	<h3 class="subsubtitle method-title">localAddress</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Returns the local address info for the socket.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (NSData *)localAddress</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Returns the local address info for the socket.</p>

<p>The localAddress method returns a sockaddr structure wrapped in a NSData object.<br/>
The <a href="#//api/name/localHost">localHost</a> method returns the human readable IP address as a string.</p>

<p>Note: Address info may not be available until after the socket has been binded, connected<br/>
or until after data has been sent.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/localAddress_IPv4" title="localAddress_IPv4"></a>
	<h3 class="subsubtitle method-title">localAddress_IPv4</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (NSData *)localAddress_IPv4</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/localAddress_IPv6" title="localAddress_IPv6"></a>
	<h3 class="subsubtitle method-title">localAddress_IPv6</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (NSData *)localAddress_IPv6</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/localHost" title="localHost"></a>
	<h3 class="subsubtitle method-title">localHost</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (NSString *)localHost</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/localHost_IPv4" title="localHost_IPv4"></a>
	<h3 class="subsubtitle method-title">localHost_IPv4</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (NSString *)localHost_IPv4</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/localHost_IPv6" title="localHost_IPv6"></a>
	<h3 class="subsubtitle method-title">localHost_IPv6</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (NSString *)localHost_IPv6</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/localPort" title="localPort"></a>
	<h3 class="subsubtitle method-title">localPort</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (uint16_t)localPort</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/localPort_IPv4" title="localPort_IPv4"></a>
	<h3 class="subsubtitle method-title">localPort_IPv4</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (uint16_t)localPort_IPv4</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/localPort_IPv6" title="localPort_IPv6"></a>
	<h3 class="subsubtitle method-title">localPort_IPv6</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (uint16_t)localPort_IPv6</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/maxReceiveIPv4BufferSize" title="maxReceiveIPv4BufferSize"></a>
	<h3 class="subsubtitle method-title">maxReceiveIPv4BufferSize</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Gets/Sets the maximum size of the buffer that will be allocated for receive operations.<br/>
The default maximum size is 9216 bytes.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (uint16_t)maxReceiveIPv4BufferSize</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Gets/Sets the maximum size of the buffer that will be allocated for receive operations.<br/>
The default maximum size is 9216 bytes.</p>

<p>The theoretical maximum size of any IPv4 UDP packet is UINT16_MAX = 65535.<br/>
The theoretical maximum size of any IPv6 UDP packet is UINT32_MAX = 4294967295.</p>

<p>Since the OS/GCD notifies us of the size of each received UDP packet,<br/>
the actual allocated buffer size for each packet is exact.<br/>
And in practice the size of UDP packets is generally much smaller than the max.<br/>
Indeed most protocols will send and receive packets of only a few bytes,<br/>
or will set a limit on the size of packets to prevent fragmentation in the IP layer.</p>

<p>If you set the buffer size too small, the sockets API in the OS will silently discard<br/>
any extra data, and you will not be notified of the error.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/maxReceiveIPv6BufferSize" title="maxReceiveIPv6BufferSize"></a>
	<h3 class="subsubtitle method-title">maxReceiveIPv6BufferSize</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (uint32_t)maxReceiveIPv6BufferSize</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/pauseReceiving" title="pauseReceiving"></a>
	<h3 class="subsubtitle method-title">pauseReceiving</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>If the socket is currently receiving (beginReceiving has been called), this method pauses the receiving.<br/>
That is, it won&rsquo;t read any more packets from the underlying OS socket until beginReceiving is called again.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)pauseReceiving</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>If the socket is currently receiving (beginReceiving has been called), this method pauses the receiving.<br/>
That is, it won&rsquo;t read any more packets from the underlying OS socket until beginReceiving is called again.</p>

<p>Important Note:<br/>
GCD<a href="../Classes/AsyncUdpSocket.html">AsyncUdpSocket</a> may be running in parallel with your code.<br/>
That is, your <a href="#//api/name/delegate">delegate</a> is likely running on a separate thread/dispatch_queue.<br/>
When you invoke this method, GCD<a href="../Classes/AsyncUdpSocket.html">AsyncUdpSocket</a> may have already dispatched <a href="#//api/name/delegate">delegate</a> methods to be invoked.<br/>
Thus, if those <a href="#//api/name/delegate">delegate</a> methods have already been dispatch_async&rsquo;d,<br/>
your didReceive <a href="#//api/name/delegate">delegate</a> method may still be invoked after this method has been called.<br/>
You should be aware of this, and program defensively.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/performBlock:" title="performBlock:"></a>
	<h3 class="subsubtitle method-title">performBlock:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>It&rsquo;s not thread-safe to access certain variables from outside the socket&rsquo;s internal queue.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)performBlock:(dispatch_block_t)<em>block</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>It&rsquo;s not thread-safe to access certain variables from outside the socket&rsquo;s internal queue.</p>

<p>For example, the socket file descriptor.<br/>
File descriptors are simply integers which reference an index in the per-process file table.<br/>
However, when one requests a new file descriptor (by opening a file or socket),<br/>
the file descriptor returned is guaranteed to be the lowest numbered unused descriptor.<br/>
So if we&rsquo;re not careful, the following could be possible:</p>

<ul>
<li>Thread A invokes a method which returns the socket&rsquo;s file descriptor.</li>
<li>The socket is closed via the socket&rsquo;s internal queue on thread B.</li>
<li>Thread C opens a file, and subsequently receives the file descriptor that was previously the socket&rsquo;s FD.</li>
<li>Thread A is now accessing/altering the file instead of the socket.</li>
</ul>


<p>In addition to this, other variables are not actually objects,<br/>
and thus cannot be retained/released or even autoreleased.<br/>
An example is the sslContext, of type SSLContextRef, which is actually a malloc&rsquo;d struct.</p>

<p>Although there are internal variables that make it difficult to maintain thread-safety,<br/>
it is important to provide access to these variables<br/>
to ensure this class can be used in a wide array of environments.<br/>
This method helps to accomplish this by invoking the current block on the socket&rsquo;s internal queue.<br/>
The methods below can be invoked from within the block to access<br/>
those generally thread-unsafe internal variables in a thread-safe manner.<br/>
The given block will be invoked synchronously on the socket&rsquo;s internal queue.</p>

<p>If you save references to any protected variables and use them outside the block, you do so at your own peril.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/readStream" title="readStream"></a>
	<h3 class="subsubtitle method-title">readStream</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>These methods are only available from within the context of a <a href="#//api/name/performBlock:">performBlock:</a> invocation.<br/>
See the documentation for the <a href="#//api/name/performBlock:">performBlock:</a> method above.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (CFReadStreamRef)readStream</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>These methods are only available from within the context of a <a href="#//api/name/performBlock:">performBlock:</a> invocation.<br/>
See the documentation for the <a href="#//api/name/performBlock:">performBlock:</a> method above.</p>

<p>Returns (creating if necessary) a CFReadStream/CFWriteStream for the internal socket.</p>

<p>Generally GCD<a href="../Classes/AsyncUdpSocket.html">AsyncUdpSocket</a> doesn&rsquo;t use CFStream. (It uses the faster GCD API&rsquo;s.)<br/>
However, if you need one for any reason,<br/>
these methods are a convenient way to get access to a safe instance of one.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/receiveOnce:" title="receiveOnce:"></a>
	<h3 class="subsubtitle method-title">receiveOnce:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>There are two modes of operation for receiving packets: one-at-a-time &amp; continuous.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (BOOL)receiveOnce:(NSError **)<em>errPtr</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>There are two modes of operation for receiving packets: one-at-a-time &amp; continuous.</p>

<p>In one-at-a-time mode, you call receiveOnce everytime your <a href="#//api/name/delegate">delegate</a> is ready to process an incoming udp packet.<br/>
Receiving packets one-at-a-time may be better suited for implementing certain state machine code,<br/>
where your state machine may not always be ready to process incoming packets.</p>

<p>In continuous mode, the <a href="#//api/name/delegate">delegate</a> is invoked immediately everytime incoming udp packets are received.<br/>
Receiving packets continuously is better suited to real-time streaming applications.</p>

<p>You may switch back and forth between one-at-a-time mode and continuous mode.<br/>
If the socket is currently in continuous mode, calling this method will switch it to one-at-a-time mode.</p>

<p>When a packet is received (and not filtered by the optional receive filter),<br/>
the <a href="#//api/name/delegate">delegate</a> method (udpSocket:didReceiveData:fromAddress:withFilterContext:) is invoked.</p>

<p>If the socket is able to begin receiving packets, this method returns YES.<br/>
Otherwise it returns NO, and sets the errPtr with appropriate error information.</p>

<p>An example error:<br/>
You created a udp socket to act as a server, and immediately called receive.<br/>
You forgot to first bind the socket to a port number, and received a error with a message like:<br/>
&ldquo;Must bind socket before you can receive data.&rdquo;</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/sendData:toAddress:withTimeout:tag:" title="sendData:toAddress:withTimeout:tag:"></a>
	<h3 class="subsubtitle method-title">sendData:toAddress:withTimeout:tag:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Asynchronously sends the given data, with the given timeout and tag, to the given address.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)sendData:(NSData *)<em>data</em> toAddress:(NSData *)<em>remoteAddr</em> withTimeout:(NSTimeInterval)<em>timeout</em> tag:(long)<em>tag</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Asynchronously sends the given data, with the given timeout and tag, to the given address.</p>

<p>This method cannot be used with a connected socket.<br/>
Recall that connecting is optional for a UDP socket.<br/>
For connected sockets, data can only be sent to the connected address.<br/>
For non-connected sockets, the remote destination is specified for each packet.<br/>
For more information about optionally connecting udp sockets, see the documentation for the connect methods above.</p>

<p>@param data<br/>
The data to send.<br/>
If data is nil or zero-length, this method does nothing.<br/>
If passing NSMutableData, please read the thread-safety notice below.</p>

<p>@param address<br/>
The address to send the data to (specified as a sockaddr structure wrapped in a NSData object).</p>

<p>@param timeout<br/>
The timeout for the send opeartion.<br/>
If the timeout value is negative, the send operation will not use a timeout.</p>

<p>@param tag<br/>
The tag is for your convenience.<br/>
It is not sent or received over the socket in any manner what-so-ever.<br/>
It is reported back as a parameter in the udpSocket:didSendDataWithTag:<br/>
or udpSocket:didNotSendDataWithTag:dueToError: methods.<br/>
You can use it as an array index, state id, type constant, etc.</p>

<p>Thread-Safety Note:<br/>
If the given data parameter is mutable (NSMutableData) then you MUST NOT alter the data while<br/>
the socket is sending it. In other words, it&rsquo;s not safe to alter the data until after the <a href="#//api/name/delegate">delegate</a> method<br/>
udpSocket:didSendDataWithTag: or udpSocket:didNotSendDataWithTag:dueToError: is invoked signifying<br/>
that this particular send operation has completed.<br/>
This is due to the fact that GCD<a href="../Classes/AsyncUdpSocket.html">AsyncUdpSocket</a> does NOT copy the data.<br/>
It simply retains it for performance reasons.<br/>
Often times, if NSMutableData is passed, it is because a request/response was built up in memory.<br/>
Copying this data adds an unwanted/unneeded overhead.<br/>
If you need to write data from an immutable buffer, and you need to alter the buffer before the socket<br/>
completes sending the bytes (which is NOT immediately after this method returns, but rather at a later time<br/>
when the <a href="#//api/name/delegate">delegate</a> method notifies you), then you should first copy the bytes, and pass the copy to this method.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/sendData:toHost:port:withTimeout:tag:" title="sendData:toHost:port:withTimeout:tag:"></a>
	<h3 class="subsubtitle method-title">sendData:toHost:port:withTimeout:tag:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Asynchronously sends the given data, with the given timeout and tag, to the given host and port.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)sendData:(NSData *)<em>data</em> toHost:(NSString *)<em>host</em> port:(uint16_t)<em>port</em> withTimeout:(NSTimeInterval)<em>timeout</em> tag:(long)<em>tag</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Asynchronously sends the given data, with the given timeout and tag, to the given host and port.</p>

<p>This method cannot be used with a connected socket.<br/>
Recall that connecting is optional for a UDP socket.<br/>
For connected sockets, data can only be sent to the connected address.<br/>
For non-connected sockets, the remote destination is specified for each packet.<br/>
For more information about optionally connecting udp sockets, see the documentation for the connect methods above.</p>

<p>@param data<br/>
The data to send.<br/>
If data is nil or zero-length, this method does nothing.<br/>
If passing NSMutableData, please read the thread-safety notice below.</p>

<p>@param host<br/>
The destination to send the udp packet to.<br/>
May be specified as a domain name (e.g. &ldquo;deusty.com&rdquo;) or an IP address string (e.g. &ldquo;192.168.0.2&rdquo;).<br/>
You may also use the convenience strings of &ldquo;loopback&rdquo; or &ldquo;localhost&rdquo;.</p>

<p>@param port<br/>
The port of the host to send to.</p>

<p>@param timeout<br/>
The timeout for the send opeartion.<br/>
If the timeout value is negative, the send operation will not use a timeout.</p>

<p>@param tag<br/>
The tag is for your convenience.<br/>
It is not sent or received over the socket in any manner what-so-ever.<br/>
It is reported back as a parameter in the udpSocket:didSendDataWithTag:<br/>
or udpSocket:didNotSendDataWithTag:dueToError: methods.<br/>
You can use it as an array index, state id, type constant, etc.</p>

<p>Thread-Safety Note:<br/>
If the given data parameter is mutable (NSMutableData) then you MUST NOT alter the data while<br/>
the socket is sending it. In other words, it&rsquo;s not safe to alter the data until after the <a href="#//api/name/delegate">delegate</a> method<br/>
udpSocket:didSendDataWithTag: or udpSocket:didNotSendDataWithTag:dueToError: is invoked signifying<br/>
that this particular send operation has completed.<br/>
This is due to the fact that GCD<a href="../Classes/AsyncUdpSocket.html">AsyncUdpSocket</a> does NOT copy the data.<br/>
It simply retains it for performance reasons.<br/>
Often times, if NSMutableData is passed, it is because a request/response was built up in memory.<br/>
Copying this data adds an unwanted/unneeded overhead.<br/>
If you need to write data from an immutable buffer, and you need to alter the buffer before the socket<br/>
completes sending the bytes (which is NOT immediately after this method returns, but rather at a later time<br/>
when the <a href="#//api/name/delegate">delegate</a> method notifies you), then you should first copy the bytes, and pass the copy to this method.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/sendData:withTimeout:tag:" title="sendData:withTimeout:tag:"></a>
	<h3 class="subsubtitle method-title">sendData:withTimeout:tag:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>Asynchronously sends the given data, with the given timeout and tag.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)sendData:(NSData *)<em>data</em> withTimeout:(NSTimeInterval)<em>timeout</em> tag:(long)<em>tag</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>Asynchronously sends the given data, with the given timeout and tag.</p>

<p>This method may only be used with a connected socket.<br/>
Recall that connecting is optional for a UDP socket.<br/>
For connected sockets, data can only be sent to the connected address.<br/>
For non-connected sockets, the remote destination is specified for each packet.<br/>
For more information about optionally connecting udp sockets, see the documentation for the connect methods above.</p>

<p>@param data<br/>
The data to send.<br/>
If data is nil or zero-length, this method does nothing.<br/>
If passing NSMutableData, please read the thread-safety notice below.</p>

<p>@param timeout<br/>
The timeout for the send opeartion.<br/>
If the timeout value is negative, the send operation will not use a timeout.</p>

<p>@param tag<br/>
The tag is for your convenience.<br/>
It is not sent or received over the socket in any manner what-so-ever.<br/>
It is reported back as a parameter in the udpSocket:didSendDataWithTag:<br/>
or udpSocket:didNotSendDataWithTag:dueToError: methods.<br/>
You can use it as an array index, state id, type constant, etc.</p>

<p>Thread-Safety Note:<br/>
If the given data parameter is mutable (NSMutableData) then you MUST NOT alter the data while<br/>
the socket is sending it. In other words, it&rsquo;s not safe to alter the data until after the <a href="#//api/name/delegate">delegate</a> method<br/>
udpSocket:didSendDataWithTag: or udpSocket:didNotSendDataWithTag:dueToError: is invoked signifying<br/>
that this particular send operation has completed.<br/>
This is due to the fact that GCD<a href="../Classes/AsyncUdpSocket.html">AsyncUdpSocket</a> does NOT copy the data.<br/>
It simply retains it for performance reasons.<br/>
Often times, if NSMutableData is passed, it is because a request/response was built up in memory.<br/>
Copying this data adds an unwanted/unneeded overhead.<br/>
If you need to write data from an immutable buffer, and you need to alter the buffer before the socket<br/>
completes sending the bytes (which is NOT immediately after this method returns, but rather at a later time<br/>
when the <a href="#//api/name/delegate">delegate</a> method notifies you), then you should first copy the bytes, and pass the copy to this method.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/setDelegate:" title="setDelegate:"></a>
	<h3 class="subsubtitle method-title">setDelegate:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)setDelegate:(id)<em>delegate</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/setDelegate:delegateQueue:" title="setDelegate:delegateQueue:"></a>
	<h3 class="subsubtitle method-title">setDelegate:delegateQueue:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)setDelegate:(id)<em>delegate</em> delegateQueue:(dispatch_queue_t)<em>delegateQueue</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/setDelegateQueue:" title="setDelegateQueue:"></a>
	<h3 class="subsubtitle method-title">setDelegateQueue:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)setDelegateQueue:(dispatch_queue_t)<em>delegateQueue</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/setIPVersionNeutral" title="setIPVersionNeutral"></a>
	<h3 class="subsubtitle method-title">setIPVersionNeutral</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)setIPVersionNeutral</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/setIPv4Enabled:" title="setIPv4Enabled:"></a>
	<h3 class="subsubtitle method-title">setIPv4Enabled:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)setIPv4Enabled:(BOOL)<em>flag</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/setIPv6Enabled:" title="setIPv6Enabled:"></a>
	<h3 class="subsubtitle method-title">setIPv6Enabled:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)setIPv6Enabled:(BOOL)<em>flag</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/setMaxReceiveIPv4BufferSize:" title="setMaxReceiveIPv4BufferSize:"></a>
	<h3 class="subsubtitle method-title">setMaxReceiveIPv4BufferSize:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)setMaxReceiveIPv4BufferSize:(uint16_t)<em>max</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/setMaxReceiveIPv6BufferSize:" title="setMaxReceiveIPv6BufferSize:"></a>
	<h3 class="subsubtitle method-title">setMaxReceiveIPv6BufferSize:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)setMaxReceiveIPv6BufferSize:(uint32_t)<em>max</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/setPreferIPv4" title="setPreferIPv4"></a>
	<h3 class="subsubtitle method-title">setPreferIPv4</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)setPreferIPv4</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/setPreferIPv6" title="setPreferIPv6"></a>
	<h3 class="subsubtitle method-title">setPreferIPv6</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)setPreferIPv6</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/setReceiveFilter:withQueue:" title="setReceiveFilter:withQueue:"></a>
	<h3 class="subsubtitle method-title">setReceiveFilter:withQueue:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>You may optionally set a receive filter for the socket.<br/>
This receive filter may be set to run in its own queue (independent of <a href="#//api/name/delegate">delegate</a> queue).</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)setReceiveFilter:(GCDAsyncUdpSocketReceiveFilterBlock)<em>filterBlock</em> withQueue:(dispatch_queue_t)<em>filterQueue</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>You may optionally set a receive filter for the socket.<br/>
This receive filter may be set to run in its own queue (independent of <a href="#//api/name/delegate">delegate</a> queue).</p>

<p>A filter can provide several useful features.</p>

<ol>
<li><p>Many times udp packets need to be parsed.<br/>
Since the filter can run in its own independent queue, you can parallelize this parsing quite easily.<br/>
The end result is a parallel socket io, datagram parsing, and packet processing.</p></li>
<li><p>Many times udp packets are discarded because they are duplicate/unneeded/unsolicited.<br/>
The filter can prevent such packets from arriving at the <a href="#//api/name/delegate">delegate</a>.<br/>
And because the filter can run in its own independent queue, this doesn&rsquo;t slow down the <a href="#//api/name/delegate">delegate</a>.</p></li>
<li><p>Since the udp protocol does not guarantee delivery, udp packets may be lost.<br/>
Many protocols built atop udp thus provide various resend/re-request algorithms.<br/>
This sometimes results in duplicate packets arriving.<br/>
A filter may allow you to architect the duplicate detection code to run in parallel to normal processing.</p></li>
<li><p>Since the udp socket may be connectionless, its possible for unsolicited packets to arrive.<br/>
Such packets need to be ignored.</p></li>
<li><p>Sometimes traffic shapers are needed to simulate real world environments.<br/>
A filter allows you to write custom code to simulate such environments.<br/>
The ability to code this yourself is especially helpful when your simulated environment<br/>
is more complicated than simple traffic shaping (e.g. simulating a cone port restricted router),<br/>
or the system tools to handle this aren&rsquo;t available (e.g. on a mobile device).</p></li>
</ol>


<p>Example:</p>

<p>GCDAsyncUdpSocketReceiveFilterBlock filter = ^BOOL (NSData <em>data, NSData </em>address, id *context) {</p>

<p>MyProtocolMessage *msg = [MyProtocol parseMessage:data];</p>

<p>*context = response;<br/>
return (response != nil);<br/>
};<br/>
[udpSocket setReceiveFilter:filter withQueue:myParsingQueue];</p>

<p>For more information about GCDAsyncUdpSocketReceiveFilterBlock, see the documentation for its typedef.<br/>
To remove a previously set filter, invoke this method and pass a nil filterBlock and NULL filterQueue.</p>

<p>Note: This method invokes <a href="#//api/name/setReceiveFilter:withQueue:isAsynchronous:">setReceiveFilter:withQueue:isAsynchronous:</a> (documented below),<br/>
passing YES for the isAsynchronous parameter.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/setReceiveFilter:withQueue:isAsynchronous:" title="setReceiveFilter:withQueue:isAsynchronous:"></a>
	<h3 class="subsubtitle method-title">setReceiveFilter:withQueue:isAsynchronous:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>The receive filter can be run via dispatch_async or dispatch_sync.<br/>
Most typical situations call for asynchronous operation.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)setReceiveFilter:(GCDAsyncUdpSocketReceiveFilterBlock)<em>filterBlock</em> withQueue:(dispatch_queue_t)<em>filterQueue</em> isAsynchronous:(BOOL)<em>isAsynchronous</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>The receive filter can be run via dispatch_async or dispatch_sync.<br/>
Most typical situations call for asynchronous operation.</p>

<p>However, there are a few situations in which synchronous operation is preferred.<br/>
Such is the case when the filter is extremely minimal and fast.<br/>
This is because dispatch_sync is faster than dispatch_async.</p>

<p>If you choose synchronous operation, be aware of possible deadlock conditions.<br/>
Since the socket queue is executing your block via dispatch_sync,<br/>
then you cannot perform any tasks which may invoke dispatch_sync on the socket queue.<br/>
For example, you can&rsquo;t query properties on the socket.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/setSendFilter:withQueue:" title="setSendFilter:withQueue:"></a>
	<h3 class="subsubtitle method-title">setSendFilter:withQueue:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>You may optionally set a send filter for the socket.<br/>
A filter can provide several interesting possibilities:</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)setSendFilter:(GCDAsyncUdpSocketSendFilterBlock)<em>filterBlock</em> withQueue:(dispatch_queue_t)<em>filterQueue</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>You may optionally set a send filter for the socket.<br/>
A filter can provide several interesting possibilities:</p>

<ol>
<li><p>Optional caching of resolved addresses for domain names.<br/>
The cache could later be consulted, resulting in fewer system calls to getaddrinfo.</p></li>
<li><p>Reusable modules of code for bandwidth monitoring.</p></li>
<li><p>Sometimes traffic shapers are needed to simulate real world environments.<br/>
A filter allows you to write custom code to simulate such environments.<br/>
The ability to code this yourself is especially helpful when your simulated environment<br/>
is more complicated than simple traffic shaping (e.g. simulating a cone port restricted router),<br/>
or the system tools to handle this aren&rsquo;t available (e.g. on a mobile device).</p></li>
</ol>


<p>For more information about GCDAsyncUdpSocketSendFilterBlock, see the documentation for its typedef.<br/>
To remove a previously set filter, invoke this method and pass a nil filterBlock and NULL filterQueue.</p>

<p>Note: This method invokes <a href="#//api/name/setSendFilter:withQueue:isAsynchronous:">setSendFilter:withQueue:isAsynchronous:</a> (documented below),<br/>
passing YES for the isAsynchronous parameter.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/setSendFilter:withQueue:isAsynchronous:" title="setSendFilter:withQueue:isAsynchronous:"></a>
	<h3 class="subsubtitle method-title">setSendFilter:withQueue:isAsynchronous:</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>The receive filter can be run via dispatch_async or dispatch_sync.<br/>
Most typical situations call for asynchronous operation.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (void)setSendFilter:(GCDAsyncUdpSocketSendFilterBlock)<em>filterBlock</em> withQueue:(dispatch_queue_t)<em>filterQueue</em> isAsynchronous:(BOOL)<em>isAsynchronous</em></code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>The receive filter can be run via dispatch_async or dispatch_sync.<br/>
Most typical situations call for asynchronous operation.</p>

<p>However, there are a few situations in which synchronous operation is preferred.<br/>
Such is the case when the filter is extremely minimal and fast.<br/>
This is because dispatch_sync is faster than dispatch_async.</p>

<p>If you choose synchronous operation, be aware of possible deadlock conditions.<br/>
Since the socket queue is executing your block via dispatch_sync,<br/>
then you cannot perform any tasks which may invoke dispatch_sync on the socket queue.<br/>
For example, you can&rsquo;t query properties on the socket.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/setUserData:" title="setUserData:"></a>
	<h3 class="subsubtitle method-title">setUserData:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)setUserData:(id)<em>arbitraryUserData</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/socket4FD" title="socket4FD"></a>
	<h3 class="subsubtitle method-title">socket4FD</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (int)socket4FD</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/socket6FD" title="socket6FD"></a>
	<h3 class="subsubtitle method-title">socket6FD</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (int)socket6FD</code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/socketFD" title="socketFD"></a>
	<h3 class="subsubtitle method-title">socketFD</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>These methods are only available from within the context of a <a href="#//api/name/performBlock:">performBlock:</a> invocation.<br/>
See the documentation for the <a href="#//api/name/performBlock:">performBlock:</a> method above.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (int)socketFD</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>These methods are only available from within the context of a <a href="#//api/name/performBlock:">performBlock:</a> invocation.<br/>
See the documentation for the <a href="#//api/name/performBlock:">performBlock:</a> method above.</p>

<p>Provides access to the socket&rsquo;s file descriptor(s).<br/>
If the socket isn&rsquo;t connected, or explicity bound to a particular interface,<br/>
it might actually have multiple internal socket file descriptors - one for IPv4 and one for IPv6.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/synchronouslySetDelegate:" title="synchronouslySetDelegate:"></a>
	<h3 class="subsubtitle method-title">synchronouslySetDelegate:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)synchronouslySetDelegate:(id)<em>delegate</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/synchronouslySetDelegate:delegateQueue:" title="synchronouslySetDelegate:delegateQueue:"></a>
	<h3 class="subsubtitle method-title">synchronouslySetDelegate:delegateQueue:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)synchronouslySetDelegate:(id)<em>delegate</em> delegateQueue:(dispatch_queue_t)<em>delegateQueue</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/synchronouslySetDelegateQueue:" title="synchronouslySetDelegateQueue:"></a>
	<h3 class="subsubtitle method-title">synchronouslySetDelegateQueue:</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (void)synchronouslySetDelegateQueue:(dispatch_queue_t)<em>delegateQueue</em></code></div>

    
</div>
						
						<div class="section-method">
	<a name="//api/name/userData" title="userData"></a>
	<h3 class="subsubtitle method-title">userData</h3>
	
	
	
	<div class="method-subsection brief-description">
		<p>User data allows you to associate arbitrary information with the socket.<br/>
This data is not used internally in any way.</p>
	</div>		
	
    

	<div class="method-subsection method-declaration"><code>- (id)userData</code></div>

    
	
	
	
	
	
	
	
	<div class="method-subsection discussion-section">
		<h4 class="method-subtitle">Discussion</h4>
		<p>User data allows you to associate arbitrary information with the socket.<br/>
This data is not used internally in any way.</p>
	</div>
	
	
	
	
	
	
	
	<div class="method-subsection declared-in-section">
		<h4 class="method-subtitle">Declared In</h4>
		<code class="declared-in-ref">GCDAsyncUdpSocket.h</code><br />
	</div>				
	
	
</div>
						
						<div class="section-method">
	<a name="//api/name/writeStream" title="writeStream"></a>
	<h3 class="subsubtitle method-title">writeStream</h3>
	
	

	<div class="method-subsection method-declaration"><code>- (CFWriteStreamRef)writeStream</code></div>

    
</div>
						
					</div>
					
					
				</div>
				<div class="main-navigation navigation-bottom">
					<ul>
	<li><a href="../index.html">Index</a></li>
	<li><a href="../hierarchy.html">Hierarchy</a></li>
</ul>
				</div>
				<div id="footer">
					<hr />
					<div class="footer-copyright">
						<p><span class="copyright">&copy; 2013 Dustin Voss and Robbie Hanson. All rights reserved. (Last updated: 2013-04-24)</span><br />
						
						<span class="generator">Generated by <a href="http://appledoc.gentlebytes.com">appledoc 2.1 (build 858)</a>.</span></p>
						
					</div>
				</div>
			</div>
		</article>
		<script type="text/javascript">
			function jumpToChange()
			{
				window.location.hash = this.options[this.selectedIndex].value;
			}
			
			function toggleTOC()
			{
				var contents = document.getElementById('contents');
				var tocContainer = document.getElementById('tocContainer');
				
				if (this.getAttribute('class') == 'open')
				{
					this.setAttribute('class', '');
					contents.setAttribute('class', '');
					tocContainer.setAttribute('class', '');
					
					window.name = "hideTOC";
				}
				else
				{
					this.setAttribute('class', 'open');
					contents.setAttribute('class', 'isShowingTOC');
					tocContainer.setAttribute('class', 'isShowingTOC');
					
					window.name = "";
				}
				return false;
			}
			
			function toggleTOCEntryChildren(e)
			{
				e.stopPropagation();
				var currentClass = this.getAttribute('class');
				if (currentClass == 'children') {
					this.setAttribute('class', 'children open');
				}
				else if (currentClass == 'children open') {
					this.setAttribute('class', 'children');
				}
				return false;
			}
			
			function tocEntryClick(e)
			{
				e.stopPropagation();
				return true;
			}
			
			function init()
			{
				var selectElement = document.getElementById('jumpTo');
				selectElement.addEventListener('change', jumpToChange, false);
				
				var tocButton = document.getElementById('table_of_contents');
				tocButton.addEventListener('click', toggleTOC, false);
				
				var taskTreeItem = document.getElementById('task_treeitem');
				if (taskTreeItem.getElementsByTagName('li').length > 0)
				{
					taskTreeItem.setAttribute('class', 'children');
					taskTreeItem.firstChild.setAttribute('class', 'disclosure');
				}
				
				var tocList = document.getElementById('toc');
				
				var tocEntries = tocList.getElementsByTagName('li');
				for (var i = 0; i < tocEntries.length; i++) {
					tocEntries[i].addEventListener('click', toggleTOCEntryChildren, false);
				}
				
				var tocLinks = tocList.getElementsByTagName('a');
				for (var i = 0; i < tocLinks.length; i++) {
					tocLinks[i].addEventListener('click', tocEntryClick, false);
				}
				
				if (window.name == "hideTOC") {
					toggleTOC.call(tocButton);
				}
			}
			
			window.onload = init;
			
			// If showing in Xcode, hide the TOC and Header
			if (navigator.userAgent.match(/xcode/i)) {
				document.getElementById("contents").className = "hideInXcode"
				document.getElementById("tocContainer").className = "hideInXcode"
				document.getElementById("top_header").className = "hideInXcode"
			}
			
		</script>
	</body>
</html>