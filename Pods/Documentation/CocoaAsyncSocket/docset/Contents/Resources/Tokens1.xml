<?xml version="1.0" encoding="UTF-8"?>
<Tokens version="1.0">
	<File path="Classes/AsyncSocket.html">
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/cl/AsyncSocket</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>
			
			<NodeRef refid="1"/>
		</Token>
		
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/init</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (id)init</Declaration>
			
			
			<Anchor>//api/name/init</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/initWithDelegate:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (id)initWithDelegate:(id)delegate</Declaration>
			
			
			<Anchor>//api/name/initWithDelegate:</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/initWithDelegate:userData:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (id)initWithDelegate:(id)delegate userData:(long)userData</Declaration>
			
			
			<Anchor>//api/name/initWithDelegate:userData:</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/description</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (NSString *)description</Declaration>
			
			
			<Anchor>//api/name/description</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/delegate</TokenIdentifier>
			<Abstract type="html">Use &quot;canSafelySetDelegate&quot; to see if there is any pending business (reads and writes) with the current delegate
before changing it.  It is, of course, safe to change the delegate before connecting or accepting connections.</Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (id)delegate</Declaration>
			
			
			<Anchor>//api/name/delegate</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/canSafelySetDelegate</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)canSafelySetDelegate</Declaration>
			
			
			<Anchor>//api/name/canSafelySetDelegate</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/setDelegate:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setDelegate:(id)delegate</Declaration>
			
			
			<Anchor>//api/name/setDelegate:</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/userData</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (long)userData</Declaration>
			
			
			<Anchor>//api/name/userData</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/setUserData:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setUserData:(long)userData</Declaration>
			
			
			<Anchor>//api/name/setUserData:</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/getCFSocket</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (CFSocketRef)getCFSocket</Declaration>
			
			
			<Anchor>//api/name/getCFSocket</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/getCFReadStream</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (CFReadStreamRef)getCFReadStream</Declaration>
			
			
			<Anchor>//api/name/getCFReadStream</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/getCFWriteStream</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (CFWriteStreamRef)getCFWriteStream</Declaration>
			
			
			<Anchor>//api/name/getCFWriteStream</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/acceptOnPort:error:</TokenIdentifier>
			<Abstract type="html">Tells the socket to begin listening and accepting connections on the given port.
When a connection comes in, the AsyncSocket instance will call the various delegate methods (see above).
The socket will listen on all available interfaces (e.g. wifi, ethernet, etc)</Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)acceptOnPort:(UInt16)port error:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/acceptOnPort:error:</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/acceptOnInterface:port:error:</TokenIdentifier>
			<Abstract type="html">This method is the same as acceptOnPort:error: with the additional option
of specifying which interface to listen on. So, for example, if you were writing code for a server that
has multiple IP addresses, you could specify which address you wanted to listen on.  Or you could use it
to specify that the socket should only accept connections over ethernet, and not other interfaces such as wifi.
You may also use the special strings &quot;localhost&quot; or &quot;loopback&quot; to specify that
the socket only accept connections from the local machine.</Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)acceptOnInterface:(NSString *)interface port:(UInt16)port error:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/acceptOnInterface:port:error:</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/connectToHost:onPort:error:</TokenIdentifier>
			<Abstract type="html">Connects to the given host and port.
The host may be a domain name (e.g. &quot;deusty.com&quot;) or an IP address string (e.g. &quot;192.168.0.2&quot;)</Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)connectToHost:(NSString *)hostname onPort:(UInt16)port error:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/connectToHost:onPort:error:</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/connectToHost:onPort:withTimeout:error:</TokenIdentifier>
			<Abstract type="html">This method is the same as connectToHost:onPort:error: with an additional timeout option.
To not time out use a negative time interval, or simply use the connectToHost:onPort:error: method.</Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)connectToHost:(NSString *)hostname onPort:(UInt16)port withTimeout:(NSTimeInterval)timeout error:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/connectToHost:onPort:withTimeout:error:</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/connectToAddress:error:</TokenIdentifier>
			<Abstract type="html">Connects to the given address, specified as a sockaddr structure wrapped in a NSData object.
For example, a NSData object returned from NSNetService&apos;s addresses method.</Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)connectToAddress:(NSData *)remoteAddr error:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/connectToAddress:error:</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/connectToAddress:withTimeout:error:</TokenIdentifier>
			<Abstract type="html">This method is the same as connectToAddress:error: with an additional timeout option.
To not time out use a negative time interval, or simply use the connectToAddress:error: method.</Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)connectToAddress:(NSData *)remoteAddr withTimeout:(NSTimeInterval)timeout error:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/connectToAddress:withTimeout:error:</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/connectToAddress:viaInterfaceAddress:withTimeout:error:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)connectToAddress:(NSData *)remoteAddr viaInterfaceAddress:(NSData *)interfaceAddr withTimeout:(NSTimeInterval)timeout error:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/connectToAddress:viaInterfaceAddress:withTimeout:error:</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/disconnect</TokenIdentifier>
			<Abstract type="html">Disconnects immediately. Any pending reads or writes are dropped.
If the socket is not already disconnected, the onSocketDidDisconnect delegate method
will be called immediately, before this method returns.</Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)disconnect</Declaration>
			
			
			<Anchor>//api/name/disconnect</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/disconnectAfterReading</TokenIdentifier>
			<Abstract type="html">Disconnects after all pending reads have completed.
After calling this, the read and write methods will do nothing.
The socket will disconnect even if there are still pending writes.</Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)disconnectAfterReading</Declaration>
			
			
			<Anchor>//api/name/disconnectAfterReading</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/disconnectAfterWriting</TokenIdentifier>
			<Abstract type="html">Disconnects after all pending writes have completed.
After calling this, the read and write methods will do nothing.
The socket will disconnect even if there are still pending reads.</Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)disconnectAfterWriting</Declaration>
			
			
			<Anchor>//api/name/disconnectAfterWriting</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/disconnectAfterReadingAndWriting</TokenIdentifier>
			<Abstract type="html">Disconnects after all pending reads and writes have completed.
After calling this, the read and write methods will do nothing.</Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)disconnectAfterReadingAndWriting</Declaration>
			
			
			<Anchor>//api/name/disconnectAfterReadingAndWriting</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/isConnected</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)isConnected</Declaration>
			
			
			<Anchor>//api/name/isConnected</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/connectedHost</TokenIdentifier>
			<Abstract type="html">Returns the local or remote host and port to which this socket is connected, or nil and 0 if not connected.
The host will be an IP address.</Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (NSString *)connectedHost</Declaration>
			
			
			<Anchor>//api/name/connectedHost</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/connectedPort</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (UInt16)connectedPort</Declaration>
			
			
			<Anchor>//api/name/connectedPort</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/localHost</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (NSString *)localHost</Declaration>
			
			
			<Anchor>//api/name/localHost</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/localPort</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (UInt16)localPort</Declaration>
			
			
			<Anchor>//api/name/localPort</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/connectedAddress</TokenIdentifier>
			<Abstract type="html">Returns the local or remote address to which this socket is connected,
specified as a sockaddr structure wrapped in a NSData object.</Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (NSData *)connectedAddress</Declaration>
			
			
			<Anchor>//api/name/connectedAddress</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/localAddress</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (NSData *)localAddress</Declaration>
			
			
			<Anchor>//api/name/localAddress</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/isIPv4</TokenIdentifier>
			<Abstract type="html">Returns whether the socket is IPv4 or IPv6.
An accepting socket may be both.</Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)isIPv4</Declaration>
			
			
			<Anchor>//api/name/isIPv4</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/isIPv6</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)isIPv6</Declaration>
			
			
			<Anchor>//api/name/isIPv6</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/readDataWithTimeout:tag:</TokenIdentifier>
			<Abstract type="html">Reads the first available bytes that become available on the socket.</Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)readDataWithTimeout:(NSTimeInterval)timeout tag:(long)tag</Declaration>
			
			
			<Anchor>//api/name/readDataWithTimeout:tag:</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/readDataWithTimeout:buffer:bufferOffset:tag:</TokenIdentifier>
			<Abstract type="html">Reads the first available bytes that become available on the socket.
The bytes will be appended to the given byte buffer starting at the given offset.
The given buffer will automatically be increased in size if needed.</Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)readDataWithTimeout:(NSTimeInterval)timeout buffer:(NSMutableData *)buffer bufferOffset:(NSUInteger)offset tag:(long)tag</Declaration>
			
			
			<Anchor>//api/name/readDataWithTimeout:buffer:bufferOffset:tag:</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/readDataWithTimeout:buffer:bufferOffset:maxLength:tag:</TokenIdentifier>
			<Abstract type="html">Reads the first available bytes that become available on the socket.
The bytes will be appended to the given byte buffer starting at the given offset.
The given buffer will automatically be increased in size if needed.
A maximum of length bytes will be read.</Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)readDataWithTimeout:(NSTimeInterval)timeout buffer:(NSMutableData *)buffer bufferOffset:(NSUInteger)offset maxLength:(NSUInteger)length tag:(long)tag</Declaration>
			
			
			<Anchor>//api/name/readDataWithTimeout:buffer:bufferOffset:maxLength:tag:</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/readDataToLength:withTimeout:tag:</TokenIdentifier>
			<Abstract type="html">Reads the given number of bytes.</Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)readDataToLength:(NSUInteger)length withTimeout:(NSTimeInterval)timeout tag:(long)tag</Declaration>
			
			
			<Anchor>//api/name/readDataToLength:withTimeout:tag:</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/readDataToLength:withTimeout:buffer:bufferOffset:tag:</TokenIdentifier>
			<Abstract type="html">Reads the given number of bytes.
The bytes will be appended to the given byte buffer starting at the given offset.
The given buffer will automatically be increased in size if needed.</Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)readDataToLength:(NSUInteger)length withTimeout:(NSTimeInterval)timeout buffer:(NSMutableData *)buffer bufferOffset:(NSUInteger)offset tag:(long)tag</Declaration>
			
			
			<Anchor>//api/name/readDataToLength:withTimeout:buffer:bufferOffset:tag:</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/readDataToData:withTimeout:tag:</TokenIdentifier>
			<Abstract type="html">Reads bytes until (and including) the passed &quot;data&quot; parameter, which acts as a separator.</Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)readDataToData:(NSData *)data withTimeout:(NSTimeInterval)timeout tag:(long)tag</Declaration>
			
			
			<Anchor>//api/name/readDataToData:withTimeout:tag:</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/readDataToData:withTimeout:buffer:bufferOffset:tag:</TokenIdentifier>
			<Abstract type="html">Reads bytes until (and including) the passed &quot;data&quot; parameter, which acts as a separator.
The bytes will be appended to the given byte buffer starting at the given offset.
The given buffer will automatically be increased in size if needed.</Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)readDataToData:(NSData *)data withTimeout:(NSTimeInterval)timeout buffer:(NSMutableData *)buffer bufferOffset:(NSUInteger)offset tag:(long)tag</Declaration>
			
			
			<Anchor>//api/name/readDataToData:withTimeout:buffer:bufferOffset:tag:</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/readDataToData:withTimeout:maxLength:tag:</TokenIdentifier>
			<Abstract type="html">Reads bytes until (and including) the passed &quot;data&quot; parameter, which acts as a separator.</Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)readDataToData:(NSData *)data withTimeout:(NSTimeInterval)timeout maxLength:(NSUInteger)length tag:(long)tag</Declaration>
			
			
			<Anchor>//api/name/readDataToData:withTimeout:maxLength:tag:</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/readDataToData:withTimeout:buffer:bufferOffset:maxLength:tag:</TokenIdentifier>
			<Abstract type="html">Reads bytes until (and including) the passed &quot;data&quot; parameter, which acts as a separator.
The bytes will be appended to the given byte buffer starting at the given offset.
The given buffer will automatically be increased in size if needed.
A maximum of length bytes will be read.</Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)readDataToData:(NSData *)data withTimeout:(NSTimeInterval)timeout buffer:(NSMutableData *)buffer bufferOffset:(NSUInteger)offset maxLength:(NSUInteger)length tag:(long)tag</Declaration>
			
			
			<Anchor>//api/name/readDataToData:withTimeout:buffer:bufferOffset:maxLength:tag:</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/writeData:withTimeout:tag:</TokenIdentifier>
			<Abstract type="html">Writes data to the socket, and calls the delegate when finished.</Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)writeData:(NSData *)data withTimeout:(NSTimeInterval)timeout tag:(long)tag</Declaration>
			
			
			<Anchor>//api/name/writeData:withTimeout:tag:</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/progressOfReadReturningTag:bytesDone:total:</TokenIdentifier>
			<Abstract type="html">Returns progress of current read or write, from 0.0 to 1.0, or NaN if no read/write (use isnan() to check).
&quot;tag&quot;, &quot;done&quot; and &quot;total&quot; will be filled in if they aren&apos;t NULL.</Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (float)progressOfReadReturningTag:(long *)tag bytesDone:(NSUInteger *)done total:(NSUInteger *)total</Declaration>
			
			
			<Anchor>//api/name/progressOfReadReturningTag:bytesDone:total:</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/progressOfWriteReturningTag:bytesDone:total:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (float)progressOfWriteReturningTag:(long *)tag bytesDone:(NSUInteger *)done total:(NSUInteger *)total</Declaration>
			
			
			<Anchor>//api/name/progressOfWriteReturningTag:bytesDone:total:</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/startTLS:</TokenIdentifier>
			<Abstract type="html">Secures the connection using SSL/TLS.</Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)startTLS:(NSDictionary *)tlsSettings</Declaration>
			
			
			<Anchor>//api/name/startTLS:</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/enablePreBuffering</TokenIdentifier>
			<Abstract type="html">For handling readDataToData requests, data is necessarily read from the socket in small increments.
The performance can be much improved by allowing AsyncSocket to read larger chunks at a time and
store any overflow in a small internal buffer.
This is termed pre-buffering, as some data may be read for you before you ask for it.
If you use readDataToData a lot, enabling pre-buffering will result in better performance, especially on the iPhone.</Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)enablePreBuffering</Declaration>
			
			
			<Anchor>//api/name/enablePreBuffering</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/moveToRunLoop:</TokenIdentifier>
			<Abstract type="html">When you create an AsyncSocket, it is added to the runloop of the current thread.
So for manually created sockets, it is easiest to simply create the socket on the thread you intend to use it.</Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)moveToRunLoop:(NSRunLoop *)runLoop</Declaration>
			
			
			<Anchor>//api/name/moveToRunLoop:</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/setRunLoopModes:</TokenIdentifier>
			<Abstract type="html">Allows you to configure which run loop modes the socket uses.
The default set of run loop modes is NSDefaultRunLoopMode.</Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)setRunLoopModes:(NSArray *)runLoopModes</Declaration>
			
			
			<Anchor>//api/name/setRunLoopModes:</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/addRunLoopMode:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)addRunLoopMode:(NSString *)runLoopMode</Declaration>
			
			
			<Anchor>//api/name/addRunLoopMode:</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/removeRunLoopMode:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)removeRunLoopMode:(NSString *)runLoopMode</Declaration>
			
			
			<Anchor>//api/name/removeRunLoopMode:</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/runLoopModes</TokenIdentifier>
			<Abstract type="html">Returns the current run loop modes the AsyncSocket instance is operating in.
The default set of run loop modes is NSDefaultRunLoopMode.</Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (NSArray *)runLoopModes</Declaration>
			
			
			<Anchor>//api/name/runLoopModes</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/AsyncSocket/unreadData</TokenIdentifier>
			<Abstract type="html">In the event of an error, this method may be called during onSocket:willDisconnectWithError: to read
any data that&apos;s left on the socket.</Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (NSData *)unreadData</Declaration>
			
			
			<Anchor>//api/name/unreadData</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/AsyncSocket/CRLFData</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>+ (NSData *)CRLFData</Declaration>
			
			
			<Anchor>//api/name/CRLFData</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/AsyncSocket/CRData</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>+ (NSData *)CRData</Declaration>
			
			
			<Anchor>//api/name/CRData</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/AsyncSocket/LFData</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>+ (NSData *)LFData</Declaration>
			
			
			<Anchor>//api/name/LFData</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/AsyncSocket/ZeroData</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>AsyncSocket.h</DeclaredIn>			
			
			<Declaration>+ (NSData *)ZeroData</Declaration>
			
			
			<Anchor>//api/name/ZeroData</Anchor>
            <NodeRef refid="1"/>
		</Token>
		
	</File>
</Tokens>