<?xml version="1.0" encoding="UTF-8"?>
<Tokens version="1.0">
	<File path="Classes/GCDAsyncUdpSocket.html">
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/cl/GCDAsyncUdpSocket</TokenIdentifier>
			<Abstract type="html">You may optionally set a send filter for the socket.
A filter can provide several interesting possibilities:</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>
			
			<NodeRef refid="4"/>
		</Token>
		
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/init</TokenIdentifier>
			<Abstract type="html">GCDAsyncUdpSocket uses the standard delegate paradigm,
but executes all delegate callbacks on a given delegate dispatch queue.
This allows for maximum concurrency, while at the same time providing easy thread safety.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (id)init</Declaration>
			
			
			<Anchor>//api/name/init</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/initWithSocketQueue:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (id)initWithSocketQueue:(dispatch_queue_t)sq</Declaration>
			
			
			<Anchor>//api/name/initWithSocketQueue:</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/initWithDelegate:delegateQueue:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (id)initWithDelegate:(id)aDelegate delegateQueue:(dispatch_queue_t)dq</Declaration>
			
			
			<Anchor>//api/name/initWithDelegate:delegateQueue:</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/initWithDelegate:delegateQueue:socketQueue:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (id)initWithDelegate:(id)aDelegate delegateQueue:(dispatch_queue_t)dq socketQueue:(dispatch_queue_t)sq</Declaration>
			
			
			<Anchor>//api/name/initWithDelegate:delegateQueue:socketQueue:</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/delegate</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (id)delegate</Declaration>
			
			
			<Anchor>//api/name/delegate</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/setDelegate:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setDelegate:(id)delegate</Declaration>
			
			
			<Anchor>//api/name/setDelegate:</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/synchronouslySetDelegate:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)synchronouslySetDelegate:(id)delegate</Declaration>
			
			
			<Anchor>//api/name/synchronouslySetDelegate:</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/delegateQueue</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (dispatch_queue_t)delegateQueue</Declaration>
			
			
			<Anchor>//api/name/delegateQueue</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/setDelegateQueue:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setDelegateQueue:(dispatch_queue_t)delegateQueue</Declaration>
			
			
			<Anchor>//api/name/setDelegateQueue:</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/synchronouslySetDelegateQueue:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)synchronouslySetDelegateQueue:(dispatch_queue_t)delegateQueue</Declaration>
			
			
			<Anchor>//api/name/synchronouslySetDelegateQueue:</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/getDelegate:delegateQueue:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)getDelegate:(id *)delegatePtr delegateQueue:(dispatch_queue_t *)delegateQueuePtr</Declaration>
			
			
			<Anchor>//api/name/getDelegate:delegateQueue:</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/setDelegate:delegateQueue:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setDelegate:(id)delegate delegateQueue:(dispatch_queue_t)delegateQueue</Declaration>
			
			
			<Anchor>//api/name/setDelegate:delegateQueue:</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/synchronouslySetDelegate:delegateQueue:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)synchronouslySetDelegate:(id)delegate delegateQueue:(dispatch_queue_t)delegateQueue</Declaration>
			
			
			<Anchor>//api/name/synchronouslySetDelegate:delegateQueue:</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/isIPv4Enabled</TokenIdentifier>
			<Abstract type="html">By default, both IPv4 and IPv6 are enabled.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)isIPv4Enabled</Declaration>
			
			
			<Anchor>//api/name/isIPv4Enabled</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/setIPv4Enabled:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setIPv4Enabled:(BOOL)flag</Declaration>
			
			
			<Anchor>//api/name/setIPv4Enabled:</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/isIPv6Enabled</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)isIPv6Enabled</Declaration>
			
			
			<Anchor>//api/name/isIPv6Enabled</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/setIPv6Enabled:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setIPv6Enabled:(BOOL)flag</Declaration>
			
			
			<Anchor>//api/name/setIPv6Enabled:</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/isIPv4Preferred</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)isIPv4Preferred</Declaration>
			
			
			<Anchor>//api/name/isIPv4Preferred</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/isIPv6Preferred</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)isIPv6Preferred</Declaration>
			
			
			<Anchor>//api/name/isIPv6Preferred</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/isIPVersionNeutral</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)isIPVersionNeutral</Declaration>
			
			
			<Anchor>//api/name/isIPVersionNeutral</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/setPreferIPv4</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setPreferIPv4</Declaration>
			
			
			<Anchor>//api/name/setPreferIPv4</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/setPreferIPv6</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setPreferIPv6</Declaration>
			
			
			<Anchor>//api/name/setPreferIPv6</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/setIPVersionNeutral</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setIPVersionNeutral</Declaration>
			
			
			<Anchor>//api/name/setIPVersionNeutral</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/maxReceiveIPv4BufferSize</TokenIdentifier>
			<Abstract type="html">Gets/Sets the maximum size of the buffer that will be allocated for receive operations.
The default maximum size is 9216 bytes.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (uint16_t)maxReceiveIPv4BufferSize</Declaration>
			
			
			<Anchor>//api/name/maxReceiveIPv4BufferSize</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/setMaxReceiveIPv4BufferSize:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setMaxReceiveIPv4BufferSize:(uint16_t)max</Declaration>
			
			
			<Anchor>//api/name/setMaxReceiveIPv4BufferSize:</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/maxReceiveIPv6BufferSize</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (uint32_t)maxReceiveIPv6BufferSize</Declaration>
			
			
			<Anchor>//api/name/maxReceiveIPv6BufferSize</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/setMaxReceiveIPv6BufferSize:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setMaxReceiveIPv6BufferSize:(uint32_t)max</Declaration>
			
			
			<Anchor>//api/name/setMaxReceiveIPv6BufferSize:</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/userData</TokenIdentifier>
			<Abstract type="html">User data allows you to associate arbitrary information with the socket.
This data is not used internally in any way.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (id)userData</Declaration>
			
			
			<Anchor>//api/name/userData</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/setUserData:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setUserData:(id)arbitraryUserData</Declaration>
			
			
			<Anchor>//api/name/setUserData:</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/localAddress</TokenIdentifier>
			<Abstract type="html">Returns the local address info for the socket.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (NSData *)localAddress</Declaration>
			
			
			<Anchor>//api/name/localAddress</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/localHost</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (NSString *)localHost</Declaration>
			
			
			<Anchor>//api/name/localHost</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/localPort</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (uint16_t)localPort</Declaration>
			
			
			<Anchor>//api/name/localPort</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/localAddress_IPv4</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (NSData *)localAddress_IPv4</Declaration>
			
			
			<Anchor>//api/name/localAddress_IPv4</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/localHost_IPv4</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (NSString *)localHost_IPv4</Declaration>
			
			
			<Anchor>//api/name/localHost_IPv4</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/localPort_IPv4</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (uint16_t)localPort_IPv4</Declaration>
			
			
			<Anchor>//api/name/localPort_IPv4</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/localAddress_IPv6</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (NSData *)localAddress_IPv6</Declaration>
			
			
			<Anchor>//api/name/localAddress_IPv6</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/localHost_IPv6</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (NSString *)localHost_IPv6</Declaration>
			
			
			<Anchor>//api/name/localHost_IPv6</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/localPort_IPv6</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (uint16_t)localPort_IPv6</Declaration>
			
			
			<Anchor>//api/name/localPort_IPv6</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/connectedAddress</TokenIdentifier>
			<Abstract type="html">Returns the remote address info for the socket.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (NSData *)connectedAddress</Declaration>
			
			
			<Anchor>//api/name/connectedAddress</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/connectedHost</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (NSString *)connectedHost</Declaration>
			
			
			<Anchor>//api/name/connectedHost</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/connectedPort</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (uint16_t)connectedPort</Declaration>
			
			
			<Anchor>//api/name/connectedPort</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/isConnected</TokenIdentifier>
			<Abstract type="html">Returns whether or not this socket has been connected to a single host.
By design, UDP is a connectionless protocol, and connecting is not needed.
If connected, the socket will only be able to send/receive data to/from the connected host.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)isConnected</Declaration>
			
			
			<Anchor>//api/name/isConnected</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/isClosed</TokenIdentifier>
			<Abstract type="html">Returns whether or not this socket has been closed.
The only way a socket can be closed is if you explicitly call one of the close methods.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)isClosed</Declaration>
			
			
			<Anchor>//api/name/isClosed</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/isIPv4</TokenIdentifier>
			<Abstract type="html">Returns whether or not this socket is IPv4.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)isIPv4</Declaration>
			
			
			<Anchor>//api/name/isIPv4</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/isIPv6</TokenIdentifier>
			<Abstract type="html">Returns whether or not this socket is IPv6.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)isIPv6</Declaration>
			
			
			<Anchor>//api/name/isIPv6</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/bindToPort:error:</TokenIdentifier>
			<Abstract type="html">Binds the UDP socket to the given port.
Binding should be done for server sockets that receive data prior to sending it.
Client sockets can skip binding,
as the OS will automatically assign the socket an available port when it starts sending data.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)bindToPort:(uint16_t)port error:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/bindToPort:error:</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/bindToPort:interface:error:</TokenIdentifier>
			<Abstract type="html">Binds the UDP socket to the given port and optional interface.
Binding should be done for server sockets that receive data prior to sending it.
Client sockets can skip binding,
as the OS will automatically assign the socket an available port when it starts sending data.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)bindToPort:(uint16_t)port interface:(NSString *)interface error:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/bindToPort:interface:error:</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/bindToAddress:error:</TokenIdentifier>
			<Abstract type="html">Binds the UDP socket to the given address, specified as a sockaddr structure wrapped in a NSData object.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)bindToAddress:(NSData *)localAddr error:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/bindToAddress:error:</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/connectToHost:onPort:error:</TokenIdentifier>
			<Abstract type="html">Connects the UDP socket to the given host and port.
By design, UDP is a connectionless protocol, and connecting is not needed.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)connectToHost:(NSString *)host onPort:(uint16_t)port error:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/connectToHost:onPort:error:</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/connectToAddress:error:</TokenIdentifier>
			<Abstract type="html">Connects the UDP socket to the given address, specified as a sockaddr structure wrapped in a NSData object.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)connectToAddress:(NSData *)remoteAddr error:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/connectToAddress:error:</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/joinMulticastGroup:error:</TokenIdentifier>
			<Abstract type="html">Join multicast group.
Group should be an IP address (eg @&quot;225.228.0.1&quot;).</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)joinMulticastGroup:(NSString *)group error:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/joinMulticastGroup:error:</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/joinMulticastGroup:onInterface:error:</TokenIdentifier>
			<Abstract type="html">Join multicast group.
Group should be an IP address (eg @&quot;225.228.0.1&quot;).
The interface may be a name (e.g. &quot;en1&quot; or &quot;lo0&quot;) or the corresponding IP address (e.g. &quot;192.168.4.35&quot;).</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)joinMulticastGroup:(NSString *)group onInterface:(NSString *)interface error:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/joinMulticastGroup:onInterface:error:</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/leaveMulticastGroup:error:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)leaveMulticastGroup:(NSString *)group error:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/leaveMulticastGroup:error:</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/leaveMulticastGroup:onInterface:error:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)leaveMulticastGroup:(NSString *)group onInterface:(NSString *)interface error:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/leaveMulticastGroup:onInterface:error:</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/enableBroadcast:error:</TokenIdentifier>
			<Abstract type="html">By default, the underlying socket in the OS will not allow you to send broadcast messages.
In order to send broadcast messages, you need to enable this functionality in the socket.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)enableBroadcast:(BOOL)flag error:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/enableBroadcast:error:</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/sendData:withTimeout:tag:</TokenIdentifier>
			<Abstract type="html">Asynchronously sends the given data, with the given timeout and tag.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)sendData:(NSData *)data withTimeout:(NSTimeInterval)timeout tag:(long)tag</Declaration>
			
			
			<Anchor>//api/name/sendData:withTimeout:tag:</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/sendData:toHost:port:withTimeout:tag:</TokenIdentifier>
			<Abstract type="html">Asynchronously sends the given data, with the given timeout and tag, to the given host and port.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)sendData:(NSData *)data toHost:(NSString *)host port:(uint16_t)port withTimeout:(NSTimeInterval)timeout tag:(long)tag</Declaration>
			
			
			<Anchor>//api/name/sendData:toHost:port:withTimeout:tag:</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/sendData:toAddress:withTimeout:tag:</TokenIdentifier>
			<Abstract type="html">Asynchronously sends the given data, with the given timeout and tag, to the given address.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)sendData:(NSData *)data toAddress:(NSData *)remoteAddr withTimeout:(NSTimeInterval)timeout tag:(long)tag</Declaration>
			
			
			<Anchor>//api/name/sendData:toAddress:withTimeout:tag:</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/setSendFilter:withQueue:</TokenIdentifier>
			<Abstract type="html">You may optionally set a send filter for the socket.
A filter can provide several interesting possibilities:</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setSendFilter:(GCDAsyncUdpSocketSendFilterBlock)filterBlock withQueue:(dispatch_queue_t)filterQueue</Declaration>
			
			
			<Anchor>//api/name/setSendFilter:withQueue:</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/setSendFilter:withQueue:isAsynchronous:</TokenIdentifier>
			<Abstract type="html">The receive filter can be run via dispatchasync or dispatchsync.
Most typical situations call for asynchronous operation.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setSendFilter:(GCDAsyncUdpSocketSendFilterBlock)filterBlock withQueue:(dispatch_queue_t)filterQueue isAsynchronous:(BOOL)isAsynchronous</Declaration>
			
			
			<Anchor>//api/name/setSendFilter:withQueue:isAsynchronous:</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/receiveOnce:</TokenIdentifier>
			<Abstract type="html">There are two modes of operation for receiving packets: one-at-a-time &amp;amp; continuous.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)receiveOnce:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/receiveOnce:</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/beginReceiving:</TokenIdentifier>
			<Abstract type="html">There are two modes of operation for receiving packets: one-at-a-time &amp;amp; continuous.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)beginReceiving:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/beginReceiving:</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/pauseReceiving</TokenIdentifier>
			<Abstract type="html">If the socket is currently receiving (beginReceiving has been called), this method pauses the receiving.
That is, it won&apos;t read any more packets from the underlying OS socket until beginReceiving is called again.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)pauseReceiving</Declaration>
			
			
			<Anchor>//api/name/pauseReceiving</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/setReceiveFilter:withQueue:</TokenIdentifier>
			<Abstract type="html">You may optionally set a receive filter for the socket.
This receive filter may be set to run in its own queue (independent of delegate queue).</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setReceiveFilter:(GCDAsyncUdpSocketReceiveFilterBlock)filterBlock withQueue:(dispatch_queue_t)filterQueue</Declaration>
			
			
			<Anchor>//api/name/setReceiveFilter:withQueue:</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/setReceiveFilter:withQueue:isAsynchronous:</TokenIdentifier>
			<Abstract type="html">The receive filter can be run via dispatchasync or dispatchsync.
Most typical situations call for asynchronous operation.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setReceiveFilter:(GCDAsyncUdpSocketReceiveFilterBlock)filterBlock withQueue:(dispatch_queue_t)filterQueue isAsynchronous:(BOOL)isAsynchronous</Declaration>
			
			
			<Anchor>//api/name/setReceiveFilter:withQueue:isAsynchronous:</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/close</TokenIdentifier>
			<Abstract type="html">Immediately closes the underlying socket.
Any pending send operations are discarded.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)close</Declaration>
			
			
			<Anchor>//api/name/close</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/closeAfterSending</TokenIdentifier>
			<Abstract type="html">Closes the underlying socket after all pending send operations have been sent.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)closeAfterSending</Declaration>
			
			
			<Anchor>//api/name/closeAfterSending</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/performBlock:</TokenIdentifier>
			<Abstract type="html">It&apos;s not thread-safe to access certain variables from outside the socket&apos;s internal queue.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (void)performBlock:(dispatch_block_t)block</Declaration>
			
			
			<Anchor>//api/name/performBlock:</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/socketFD</TokenIdentifier>
			<Abstract type="html">These methods are only available from within the context of a performBlock: invocation.
See the documentation for the performBlock: method above.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (int)socketFD</Declaration>
			
			
			<Anchor>//api/name/socketFD</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/socket4FD</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (int)socket4FD</Declaration>
			
			
			<Anchor>//api/name/socket4FD</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/socket6FD</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (int)socket6FD</Declaration>
			
			
			<Anchor>//api/name/socket6FD</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/readStream</TokenIdentifier>
			<Abstract type="html">These methods are only available from within the context of a performBlock: invocation.
See the documentation for the performBlock: method above.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (CFReadStreamRef)readStream</Declaration>
			
			
			<Anchor>//api/name/readStream</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncUdpSocket/writeStream</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>- (CFWriteStreamRef)writeStream</Declaration>
			
			
			<Anchor>//api/name/writeStream</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/GCDAsyncUdpSocket/hostFromAddress:</TokenIdentifier>
			<Abstract type="html">Extracting host/port/family information from raw address data.</Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>+ (NSString *)hostFromAddress:(NSData *)address</Declaration>
			
			
			<Anchor>//api/name/hostFromAddress:</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/GCDAsyncUdpSocket/portFromAddress:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>+ (uint16_t)portFromAddress:(NSData *)address</Declaration>
			
			
			<Anchor>//api/name/portFromAddress:</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/GCDAsyncUdpSocket/familyFromAddress:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>+ (int)familyFromAddress:(NSData *)address</Declaration>
			
			
			<Anchor>//api/name/familyFromAddress:</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/GCDAsyncUdpSocket/isIPv4Address:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>+ (BOOL)isIPv4Address:(NSData *)address</Declaration>
			
			
			<Anchor>//api/name/isIPv4Address:</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/GCDAsyncUdpSocket/isIPv6Address:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>+ (BOOL)isIPv6Address:(NSData *)address</Declaration>
			
			
			<Anchor>//api/name/isIPv6Address:</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/GCDAsyncUdpSocket/getHost:port:fromAddress:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>+ (BOOL)getHost:(NSString **)hostPtr port:(uint16_t *)portPtr fromAddress:(NSData *)address</Declaration>
			
			
			<Anchor>//api/name/getHost:port:fromAddress:</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/GCDAsyncUdpSocket/getHost:port:family:fromAddress:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncUdpSocket.h</DeclaredIn>			
			
			<Declaration>+ (BOOL)getHost:(NSString **)hostPtr port:(uint16_t *)portPtr family:(int *)afPtr fromAddress:(NSData *)address</Declaration>
			
			
			<Anchor>//api/name/getHost:port:family:fromAddress:</Anchor>
            <NodeRef refid="4"/>
		</Token>
		
	</File>
</Tokens>