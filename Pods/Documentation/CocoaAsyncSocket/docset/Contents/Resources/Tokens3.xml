<?xml version="1.0" encoding="UTF-8"?>
<Tokens version="1.0">
	<File path="Classes/GCDAsyncSocket.html">
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/cl/GCDAsyncSocket</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>
			
			<NodeRef refid="3"/>
		</Token>
		
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/init</TokenIdentifier>
			<Abstract type="html">GCDAsyncSocket uses the standard delegate paradigm,
but executes all delegate callbacks on a given delegate dispatch queue.
This allows for maximum concurrency, while at the same time providing easy thread safety.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (id)init</Declaration>
			
			
			<Anchor>//api/name/init</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/initWithSocketQueue:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (id)initWithSocketQueue:(dispatch_queue_t)sq</Declaration>
			
			
			<Anchor>//api/name/initWithSocketQueue:</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/initWithDelegate:delegateQueue:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (id)initWithDelegate:(id)aDelegate delegateQueue:(dispatch_queue_t)dq</Declaration>
			
			
			<Anchor>//api/name/initWithDelegate:delegateQueue:</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/initWithDelegate:delegateQueue:socketQueue:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (id)initWithDelegate:(id)aDelegate delegateQueue:(dispatch_queue_t)dq socketQueue:(dispatch_queue_t)sq</Declaration>
			
			
			<Anchor>//api/name/initWithDelegate:delegateQueue:socketQueue:</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/delegate</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (id)delegate</Declaration>
			
			
			<Anchor>//api/name/delegate</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/setDelegate:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setDelegate:(id)delegate</Declaration>
			
			
			<Anchor>//api/name/setDelegate:</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/synchronouslySetDelegate:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)synchronouslySetDelegate:(id)delegate</Declaration>
			
			
			<Anchor>//api/name/synchronouslySetDelegate:</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/delegateQueue</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (dispatch_queue_t)delegateQueue</Declaration>
			
			
			<Anchor>//api/name/delegateQueue</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/setDelegateQueue:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setDelegateQueue:(dispatch_queue_t)delegateQueue</Declaration>
			
			
			<Anchor>//api/name/setDelegateQueue:</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/synchronouslySetDelegateQueue:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)synchronouslySetDelegateQueue:(dispatch_queue_t)delegateQueue</Declaration>
			
			
			<Anchor>//api/name/synchronouslySetDelegateQueue:</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/getDelegate:delegateQueue:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)getDelegate:(id *)delegatePtr delegateQueue:(dispatch_queue_t *)delegateQueuePtr</Declaration>
			
			
			<Anchor>//api/name/getDelegate:delegateQueue:</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/setDelegate:delegateQueue:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setDelegate:(id)delegate delegateQueue:(dispatch_queue_t)delegateQueue</Declaration>
			
			
			<Anchor>//api/name/setDelegate:delegateQueue:</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/synchronouslySetDelegate:delegateQueue:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)synchronouslySetDelegate:(id)delegate delegateQueue:(dispatch_queue_t)delegateQueue</Declaration>
			
			
			<Anchor>//api/name/synchronouslySetDelegate:delegateQueue:</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/autoDisconnectOnClosedReadStream</TokenIdentifier>
			<Abstract type="html">Traditionally sockets are not closed until the conversation is over.
However, it is technically possible for the remote enpoint to close its write stream.
Our socket would then be notified that there is no more data to be read,
but our socket would still be writeable and the remote endpoint could continue to receive our data.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)autoDisconnectOnClosedReadStream</Declaration>
			
			
			<Anchor>//api/name/autoDisconnectOnClosedReadStream</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/setAutoDisconnectOnClosedReadStream:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setAutoDisconnectOnClosedReadStream:(BOOL)flag</Declaration>
			
			
			<Anchor>//api/name/setAutoDisconnectOnClosedReadStream:</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/isIPv4Enabled</TokenIdentifier>
			<Abstract type="html">By default, both IPv4 and IPv6 are enabled.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)isIPv4Enabled</Declaration>
			
			
			<Anchor>//api/name/isIPv4Enabled</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/setIPv4Enabled:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setIPv4Enabled:(BOOL)flag</Declaration>
			
			
			<Anchor>//api/name/setIPv4Enabled:</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/isIPv6Enabled</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)isIPv6Enabled</Declaration>
			
			
			<Anchor>//api/name/isIPv6Enabled</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/setIPv6Enabled:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setIPv6Enabled:(BOOL)flag</Declaration>
			
			
			<Anchor>//api/name/setIPv6Enabled:</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/isIPv4PreferredOverIPv6</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)isIPv4PreferredOverIPv6</Declaration>
			
			
			<Anchor>//api/name/isIPv4PreferredOverIPv6</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/setPreferIPv4OverIPv6:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setPreferIPv4OverIPv6:(BOOL)flag</Declaration>
			
			
			<Anchor>//api/name/setPreferIPv4OverIPv6:</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/userData</TokenIdentifier>
			<Abstract type="html">User data allows you to associate arbitrary information with the socket.
This data is not used internally by socket in any way.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (id)userData</Declaration>
			
			
			<Anchor>//api/name/userData</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/setUserData:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)setUserData:(id)arbitraryUserData</Declaration>
			
			
			<Anchor>//api/name/setUserData:</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/acceptOnPort:error:</TokenIdentifier>
			<Abstract type="html">Tells the socket to begin listening and accepting connections on the given port.
When a connection is accepted, a new instance of GCDAsyncSocket will be spawned to handle it,
and the socket:didAcceptNewSocket: delegate method will be invoked.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)acceptOnPort:(uint16_t)port error:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/acceptOnPort:error:</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/acceptOnInterface:port:error:</TokenIdentifier>
			<Abstract type="html">This method is the same as acceptOnPort:error: with the
additional option of specifying which interface to listen on.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)acceptOnInterface:(NSString *)interface port:(uint16_t)port error:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/acceptOnInterface:port:error:</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/connectToHost:onPort:error:</TokenIdentifier>
			<Abstract type="html">Connects to the given host and port.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)connectToHost:(NSString *)host onPort:(uint16_t)port error:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/connectToHost:onPort:error:</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/connectToHost:onPort:withTimeout:error:</TokenIdentifier>
			<Abstract type="html">Connects to the given host and port with an optional timeout.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)connectToHost:(NSString *)host onPort:(uint16_t)port withTimeout:(NSTimeInterval)timeout error:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/connectToHost:onPort:withTimeout:error:</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/connectToHost:onPort:viaInterface:withTimeout:error:</TokenIdentifier>
			<Abstract type="html">Connects to the given host &amp;amp; port, via the optional interface, with an optional timeout.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)connectToHost:(NSString *)host onPort:(uint16_t)port viaInterface:(NSString *)interface withTimeout:(NSTimeInterval)timeout error:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/connectToHost:onPort:viaInterface:withTimeout:error:</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/connectToAddress:error:</TokenIdentifier>
			<Abstract type="html">Connects to the given address, specified as a sockaddr structure wrapped in a NSData object.
For example, a NSData object returned from NSNetService&apos;s addresses method.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)connectToAddress:(NSData *)remoteAddr error:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/connectToAddress:error:</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/connectToAddress:withTimeout:error:</TokenIdentifier>
			<Abstract type="html">This method is the same as connectToAddress:error: with an additional timeout option.
To not time out use a negative time interval, or simply use the connectToAddress:error: method.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)connectToAddress:(NSData *)remoteAddr withTimeout:(NSTimeInterval)timeout error:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/connectToAddress:withTimeout:error:</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/connectToAddress:viaInterface:withTimeout:error:</TokenIdentifier>
			<Abstract type="html">Connects to the given address, using the specified interface and timeout.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)connectToAddress:(NSData *)remoteAddr viaInterface:(NSString *)interface withTimeout:(NSTimeInterval)timeout error:(NSError **)errPtr</Declaration>
			
			
			<Anchor>//api/name/connectToAddress:viaInterface:withTimeout:error:</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/disconnect</TokenIdentifier>
			<Abstract type="html">Disconnects immediately (synchronously). Any pending reads or writes are dropped.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)disconnect</Declaration>
			
			
			<Anchor>//api/name/disconnect</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/disconnectAfterReading</TokenIdentifier>
			<Abstract type="html">Disconnects after all pending reads have completed.
After calling this, the read and write methods will do nothing.
The socket will disconnect even if there are still pending writes.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)disconnectAfterReading</Declaration>
			
			
			<Anchor>//api/name/disconnectAfterReading</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/disconnectAfterWriting</TokenIdentifier>
			<Abstract type="html">Disconnects after all pending writes have completed.
After calling this, the read and write methods will do nothing.
The socket will disconnect even if there are still pending reads.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)disconnectAfterWriting</Declaration>
			
			
			<Anchor>//api/name/disconnectAfterWriting</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/disconnectAfterReadingAndWriting</TokenIdentifier>
			<Abstract type="html">Disconnects after all pending reads and writes have completed.
After calling this, the read and write methods will do nothing.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)disconnectAfterReadingAndWriting</Declaration>
			
			
			<Anchor>//api/name/disconnectAfterReadingAndWriting</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/isDisconnected</TokenIdentifier>
			<Abstract type="html">Returns whether the socket is disconnected or connected.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)isDisconnected</Declaration>
			
			
			<Anchor>//api/name/isDisconnected</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/isConnected</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)isConnected</Declaration>
			
			
			<Anchor>//api/name/isConnected</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/connectedHost</TokenIdentifier>
			<Abstract type="html">Returns the local or remote host and port to which this socket is connected, or nil and 0 if not connected.
The host will be an IP address.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (NSString *)connectedHost</Declaration>
			
			
			<Anchor>//api/name/connectedHost</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/connectedPort</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (uint16_t)connectedPort</Declaration>
			
			
			<Anchor>//api/name/connectedPort</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/localHost</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (NSString *)localHost</Declaration>
			
			
			<Anchor>//api/name/localHost</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/localPort</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (uint16_t)localPort</Declaration>
			
			
			<Anchor>//api/name/localPort</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/connectedAddress</TokenIdentifier>
			<Abstract type="html">Returns the local or remote address to which this socket is connected,
specified as a sockaddr structure wrapped in a NSData object.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (NSData *)connectedAddress</Declaration>
			
			
			<Anchor>//api/name/connectedAddress</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/localAddress</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (NSData *)localAddress</Declaration>
			
			
			<Anchor>//api/name/localAddress</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/isIPv4</TokenIdentifier>
			<Abstract type="html">Returns whether the socket is IPv4 or IPv6.
An accepting socket may be both.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)isIPv4</Declaration>
			
			
			<Anchor>//api/name/isIPv4</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/isIPv6</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)isIPv6</Declaration>
			
			
			<Anchor>//api/name/isIPv6</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/isSecure</TokenIdentifier>
			<Abstract type="html">Returns whether or not the socket has been secured via SSL/TLS.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)isSecure</Declaration>
			
			
			<Anchor>//api/name/isSecure</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/readDataWithTimeout:tag:</TokenIdentifier>
			<Abstract type="html">Reads the first available bytes that become available on the socket.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)readDataWithTimeout:(NSTimeInterval)timeout tag:(long)tag</Declaration>
			
			
			<Anchor>//api/name/readDataWithTimeout:tag:</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/readDataWithTimeout:buffer:bufferOffset:tag:</TokenIdentifier>
			<Abstract type="html">Reads the first available bytes that become available on the socket.
The bytes will be appended to the given byte buffer starting at the given offset.
The given buffer will automatically be increased in size if needed.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)readDataWithTimeout:(NSTimeInterval)timeout buffer:(NSMutableData *)buffer bufferOffset:(NSUInteger)offset tag:(long)tag</Declaration>
			
			
			<Anchor>//api/name/readDataWithTimeout:buffer:bufferOffset:tag:</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/readDataWithTimeout:buffer:bufferOffset:maxLength:tag:</TokenIdentifier>
			<Abstract type="html">Reads the first available bytes that become available on the socket.
The bytes will be appended to the given byte buffer starting at the given offset.
The given buffer will automatically be increased in size if needed.
A maximum of length bytes will be read.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)readDataWithTimeout:(NSTimeInterval)timeout buffer:(NSMutableData *)buffer bufferOffset:(NSUInteger)offset maxLength:(NSUInteger)length tag:(long)tag</Declaration>
			
			
			<Anchor>//api/name/readDataWithTimeout:buffer:bufferOffset:maxLength:tag:</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/readDataToLength:withTimeout:tag:</TokenIdentifier>
			<Abstract type="html">Reads the given number of bytes.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)readDataToLength:(NSUInteger)length withTimeout:(NSTimeInterval)timeout tag:(long)tag</Declaration>
			
			
			<Anchor>//api/name/readDataToLength:withTimeout:tag:</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/readDataToLength:withTimeout:buffer:bufferOffset:tag:</TokenIdentifier>
			<Abstract type="html">Reads the given number of bytes.
The bytes will be appended to the given byte buffer starting at the given offset.
The given buffer will automatically be increased in size if needed.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)readDataToLength:(NSUInteger)length withTimeout:(NSTimeInterval)timeout buffer:(NSMutableData *)buffer bufferOffset:(NSUInteger)offset tag:(long)tag</Declaration>
			
			
			<Anchor>//api/name/readDataToLength:withTimeout:buffer:bufferOffset:tag:</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/readDataToData:withTimeout:tag:</TokenIdentifier>
			<Abstract type="html">Reads bytes until (and including) the passed &quot;data&quot; parameter, which acts as a separator.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)readDataToData:(NSData *)data withTimeout:(NSTimeInterval)timeout tag:(long)tag</Declaration>
			
			
			<Anchor>//api/name/readDataToData:withTimeout:tag:</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/readDataToData:withTimeout:buffer:bufferOffset:tag:</TokenIdentifier>
			<Abstract type="html">Reads bytes until (and including) the passed &quot;data&quot; parameter, which acts as a separator.
The bytes will be appended to the given byte buffer starting at the given offset.
The given buffer will automatically be increased in size if needed.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)readDataToData:(NSData *)data withTimeout:(NSTimeInterval)timeout buffer:(NSMutableData *)buffer bufferOffset:(NSUInteger)offset tag:(long)tag</Declaration>
			
			
			<Anchor>//api/name/readDataToData:withTimeout:buffer:bufferOffset:tag:</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/readDataToData:withTimeout:maxLength:tag:</TokenIdentifier>
			<Abstract type="html">Reads bytes until (and including) the passed &quot;data&quot; parameter, which acts as a separator.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)readDataToData:(NSData *)data withTimeout:(NSTimeInterval)timeout maxLength:(NSUInteger)length tag:(long)tag</Declaration>
			
			
			<Anchor>//api/name/readDataToData:withTimeout:maxLength:tag:</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/readDataToData:withTimeout:buffer:bufferOffset:maxLength:tag:</TokenIdentifier>
			<Abstract type="html">Reads bytes until (and including) the passed &quot;data&quot; parameter, which acts as a separator.
The bytes will be appended to the given byte buffer starting at the given offset.
The given buffer will automatically be increased in size if needed.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)readDataToData:(NSData *)data withTimeout:(NSTimeInterval)timeout buffer:(NSMutableData *)buffer bufferOffset:(NSUInteger)offset maxLength:(NSUInteger)length tag:(long)tag</Declaration>
			
			
			<Anchor>//api/name/readDataToData:withTimeout:buffer:bufferOffset:maxLength:tag:</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/progressOfReadReturningTag:bytesDone:total:</TokenIdentifier>
			<Abstract type="html">Returns progress of the current read, from 0.0 to 1.0, or NaN if no current read (use isnan() to check).
The parameters &quot;tag&quot;, &quot;done&quot; and &quot;total&quot; will be filled in if they aren&apos;t NULL.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (float)progressOfReadReturningTag:(long *)tagPtr bytesDone:(NSUInteger *)donePtr total:(NSUInteger *)totalPtr</Declaration>
			
			
			<Anchor>//api/name/progressOfReadReturningTag:bytesDone:total:</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/writeData:withTimeout:tag:</TokenIdentifier>
			<Abstract type="html">Writes data to the socket, and calls the delegate when finished.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)writeData:(NSData *)data withTimeout:(NSTimeInterval)timeout tag:(long)tag</Declaration>
			
			
			<Anchor>//api/name/writeData:withTimeout:tag:</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/progressOfWriteReturningTag:bytesDone:total:</TokenIdentifier>
			<Abstract type="html">Returns progress of the current write, from 0.0 to 1.0, or NaN if no current write (use isnan() to check).
The parameters &quot;tag&quot;, &quot;done&quot; and &quot;total&quot; will be filled in if they aren&apos;t NULL.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (float)progressOfWriteReturningTag:(long *)tagPtr bytesDone:(NSUInteger *)donePtr total:(NSUInteger *)totalPtr</Declaration>
			
			
			<Anchor>//api/name/progressOfWriteReturningTag:bytesDone:total:</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/startTLS:</TokenIdentifier>
			<Abstract type="html">Secures the connection using SSL/TLS.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)startTLS:(NSDictionary *)tlsSettings</Declaration>
			
			
			<Anchor>//api/name/startTLS:</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/performBlock:</TokenIdentifier>
			<Abstract type="html">It&apos;s not thread-safe to access certain variables from outside the socket&apos;s internal queue.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (void)performBlock:(dispatch_block_t)block</Declaration>
			
			
			<Anchor>//api/name/performBlock:</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/socketFD</TokenIdentifier>
			<Abstract type="html">These methods are only available from within the context of a performBlock: invocation.
See the documentation for the performBlock: method above.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (int)socketFD</Declaration>
			
			
			<Anchor>//api/name/socketFD</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/socket4FD</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (int)socket4FD</Declaration>
			
			
			<Anchor>//api/name/socket4FD</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/socket6FD</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (int)socket6FD</Declaration>
			
			
			<Anchor>//api/name/socket6FD</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/readStream</TokenIdentifier>
			<Abstract type="html">These methods are only available from within the context of a performBlock: invocation.
See the documentation for the performBlock: method above.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (CFReadStreamRef)readStream</Declaration>
			
			
			<Anchor>//api/name/readStream</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/writeStream</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (CFWriteStreamRef)writeStream</Declaration>
			
			
			<Anchor>//api/name/writeStream</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/enableBackgroundingOnSocket</TokenIdentifier>
			<Abstract type="html">This method is only available from within the context of a performBlock: invocation.
See the documentation for the performBlock: method above.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (BOOL)enableBackgroundingOnSocket</Declaration>
			
			
			<Anchor>//api/name/enableBackgroundingOnSocket</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/instm/GCDAsyncSocket/sslContext</TokenIdentifier>
			<Abstract type="html">This method is only available from within the context of a performBlock: invocation.
See the documentation for the performBlock: method above.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>- (SSLContextRef)sslContext</Declaration>
			
			
			<Anchor>//api/name/sslContext</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/GCDAsyncSocket/hostFromAddress:</TokenIdentifier>
			<Abstract type="html">Extracting host and port information from raw address data.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>+ (NSString *)hostFromAddress:(NSData *)address</Declaration>
			
			
			<Anchor>//api/name/hostFromAddress:</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/GCDAsyncSocket/portFromAddress:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>+ (uint16_t)portFromAddress:(NSData *)address</Declaration>
			
			
			<Anchor>//api/name/portFromAddress:</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/GCDAsyncSocket/getHost:port:fromAddress:</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>+ (BOOL)getHost:(NSString **)hostPtr port:(uint16_t *)portPtr fromAddress:(NSData *)address</Declaration>
			
			
			<Anchor>//api/name/getHost:port:fromAddress:</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/GCDAsyncSocket/CRLFData</TokenIdentifier>
			<Abstract type="html">A few common line separators, for use with the readDataToData:... methods.</Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>+ (NSData *)CRLFData</Declaration>
			
			
			<Anchor>//api/name/CRLFData</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/GCDAsyncSocket/CRData</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>+ (NSData *)CRData</Declaration>
			
			
			<Anchor>//api/name/CRData</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/GCDAsyncSocket/LFData</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>+ (NSData *)LFData</Declaration>
			
			
			<Anchor>//api/name/LFData</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
		<Token>
			<TokenIdentifier>//apple_ref/occ/clm/GCDAsyncSocket/ZeroData</TokenIdentifier>
			<Abstract type="html"></Abstract>
			<DeclaredIn>GCDAsyncSocket.h</DeclaredIn>			
			
			<Declaration>+ (NSData *)ZeroData</Declaration>
			
			
			<Anchor>//api/name/ZeroData</Anchor>
            <NodeRef refid="3"/>
		</Token>
		
	</File>
</Tokens>